<html><title>Assembly Tricks</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

Super Mario Brothers 1 is an amazing technical feat. Every last byte of the 32KB available program space is utilized. In fact, some bytes are even dual purposed to save space.<!--more--> Have a look at this code from our Super Mario 1 disassembly:

<div class="nul"><pre>
Label_8220:
    LDY #$00
    .db $2c
Label_8223:
    LDY #$04
    LDA #$f8
Label_8227:
    STA $0200, Y
    INY
    INY
    INY
    INY
    BNE Label_8227
    RTS
</pre></div>

Note the <code>.db $2c</code>. <code>$2c</code> is the op code for <coce>BIT</code> absolute, which is 3 bytes - 1 byte op code and then 2 bytes for the absolute address. <code>LDY #$04</code> is 2 bytes - <code>$a0</code> for the op code and then <code>$04</code> for the immediate value.
<P>
So how this works is if you jump to <code>Label_8220</code>, it does <code>Y = $00</code>, and then sabotages the next instruction, causing the <code>Y = $04</code> to not happen. Instead, the <code>BIT</code> instruction sets some status bits in a way that does not matter. Then it picks up the next instruction, <code>LDA #$f8</code>, as if you had jumped to <code>Label_8223</code> with a different <code>Y</code>.
<P>
This occurs over a dozen times in Super Mario 1. Similarly, there are instances where the program jumps into the middle of an instruction. Yet another trick is adding an address on the stack and then using the <code>RTS</code> instruction to jump there, kind of like a homebrew <code>JMP</code> indirect instruction. And even with indirect <code>JMP</code> instructions, the programmer may choose to jump to RAM or somewhere other than a label.
<P>
These issues must be resolved if we want a playable game. Sadly, the solution marks the final nail in the coffin of the integrity of this project.
<P>
The solution is to embed an interpreter runtime in the generated binary:

<div class="dir">
Instead of identifying data that is read and only including that in the generated module, include all the PRG ROM, since we don't know which addresses may be accessed at runtime.
</div>

<div class="dir">
After every instruction, update the program counter variable.
</div>

<div class="dir">
Include a basic block in <code>rom_start</code> called <code>Interpret</code> which reads the program counter variable, reads the op code from the PRG ROM, performs the necessary operation, and then jumps to the <code>DynJumpTable</code> block.
</div>

<div class="dir">
When control flow runs into data, branch to the <code>Interpret</code> block.
</div>

Here's a diagram to help clarify:

<div class="dir">
start <code>Statically Recompiled code execution</code> Inaderect jump <code>DynJumpTable Block</code> Jump address not a label <code>Interpret Block</code>
</div>

<div class="dir">
start <code>Statically Recompiled code execution</code> Control flow runs ito data <code>Interpret Block</code>
</div>

<div class="dir">
<code>Interpret Block</code> after interpreting one instruction <code>DynJumpTable Block</code> Jump aaddress is a lable <code>Statically Recompiled code execution</code>
</div>

This strategy ensures that NES games will run correctly, at the cost of efficiency. Normally, doing something like updating the program counter variable after every instruction would be optimized away, but this is thwarted by interrupts in our case. Because after every instruction we call <code>rom_cycle</code>, which in turn might call <code>rom_start</code> with an interrupt, all the global variable state must be correct before we call rom_cycle. This defeats the entire point of this project. At this point we might as well emulate. In fact, with the new <code>Interpret</code> block, we are doing just that. Although, to be fair, I only had to add emulation support for 6 op codes to get Super Mario Brothers 1 working.


</body>
</html>
