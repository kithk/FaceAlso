<html><title>Runtime Address Checks</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

Looking at the disassembled code for Zelda Title Screen Simulator, there is one instruction that stands out as a bit more tricky to recompile than the others<!--more-->:

<div class="nul">
STA ($00), Y
</div>

This is an indirect instruction. It tells the CPU to:

<div class="dir">
Interpret the values in $0000 and $0001 as a memory address.
</div>

<div class="dir">
Add the value of register Y to the address to compute a new address.
</div>

<div class="dir">
Store the value of register A to the new address.
</div>

Quite a useful instruction, but it poses a challenge for recompilation. Because values in memory addresses $0000 and $0001 could be anything, only at runtime will we learn which memory address is about to be updated.
<div class="dir">
<a href="http://aondir.blogspot.com/search?q=Recompiling+NES+Games&amp;max-results=21">!Table of Contents More</a>
</div>
Recall that the NES uses memory mapped I/O. This means that this instruction could be saving a value in memory, but it could also be talking to the PPU, the APU, the game pad controller, or even a mapper. Since this one instruction could be doing any of these things depending on runtime state, we will have to add a runtime address check.
<P>
Here's what the code generation looks like for STA-indirect-Y:

<div class="nul"><pre>
func (i *Instruction) Compile(c *Compilation) {
 switch i.OpCode {
 // ... more cases for other indirect instructions

 case 0x91: // sta indirect y
  // load the base address at the address indicated by the instruction
  baseAddr := c.loadWord(i.Value)
  // load the 8-bit value of register Y
  rY := c.builder.CreateLoad(c.rY, "")
  // zero extend the 8-bit value of Y to 16 bits
  // so that we can add it to baseAddr
  rYw := c.builder.CreateZExt(rY, llvm.Int16Type(), "")
  // compute the pointer to the address to store a byte
  addr := c.builder.CreateAdd(baseAddr, rYw, "")
  // load the value of register A
  rA := c.builder.CreateLoad(c.rA, "")
  // call dynStore with our computed address and value of A.
  // dynStore will figure out what to do with the value and address.
  c.dynStore(addr, rA)
 }
}

func (c *Compilation) loadWord(addr int) llvm.Value {
 // Load a little endian word.

 // Load the low byte.
 ptrByte1 := c.load(addr)
 // Load the high byte.
 ptrByte2 := c.load(addr + 1)

 // Zero extend the 8-bit values to 16-bit.
 ptrByte1w := c.builder.CreateZExt(ptrByte1, llvm.Int16Type(), "")
 ptrByte2w := c.builder.CreateZExt(ptrByte2, llvm.Int16Type(), "")

 // Shift the high byte left by 8.
 shiftAmt := llvm.ConstInt(llvm.Int16Type(), 8, false)
 word := c.builder.CreateShl(ptrByte2w, shiftAmt, "")

 // Bitwise OR the high and low bytes together and return that.
 return c.builder.CreateOr(word, ptrByte1w, "")
}

func (c *Compilation) load(addr int) llvm.Value {
 // This function is used to load a byte from an address that we know
 // at compile-time.
 switch {
 default:
  c.Errors = append(c.Errors, fmt.Sprintf("reading from $%04x not implemented", addr))
  return llvm.ConstNull(llvm.Int8Type())
 case 0x0000 &lt;= addr && addr &lt; 0x2000:
  // 2KB working RAM. mask because mirrored
  maskedAddr := addr & (0x800 - 1)
  indexes := []llvm.Value{
   llvm.ConstInt(llvm.Int16Type(), 0, false),
   llvm.ConstInt(llvm.Int16Type(), uint64(maskedAddr), false),
  }
  ptr := c.builder.CreateGEP(c.wram, indexes, "")
  v := c.builder.CreateLoad(ptr, "")
  return v
 case 0x2000 &lt;= addr && addr &lt; 0x4000:
  // PPU registers. mask because mirrored
  switch addr & (0x8 - 1) {
  case 2:
   return c.builder.CreateCall(c.ppuReadStatusFn, []llvm.Value{}, "")
  case 4:
   return c.builder.CreateCall(c.ppuReadOamDataFn, []llvm.Value{}, "")
  case 7:
   return c.builder.CreateCall(c.ppuReadDataFn, []llvm.Value{}, "")
  default:
   c.Errors = append(c.Errors, fmt.Sprintf("reading from $%04x not implemented", addr))
   return llvm.ConstNull(llvm.Int8Type())
  }

 // ... There are more cases to handle; here we only include WRAM and the PPU.

 }
 panic("unreachable")
}

func (c *Compilation) dynStore(addr llvm.Value, val llvm.Value) {
 // runtime memory check
 storeDoneBlock := c.createBlock("StoreDone")
 x2000 := llvm.ConstInt(llvm.Int16Type(), 0x2000, false)
 inWRam := c.builder.CreateICmp(llvm.IntULT, addr, x2000, "")
 notInWRamBlock := c.createIf(inWRam)
 // this generated code runs if the write is happening in the WRAM range
 maskedAddr := c.builder.CreateAnd(addr, llvm.ConstInt(llvm.Int16Type(), 0x800-1, false), "")
 indexes := []llvm.Value{
  llvm.ConstInt(llvm.Int16Type(), 0, false),
  maskedAddr,
 }
 ptr := c.builder.CreateGEP(c.wram, indexes, "")
 c.builder.CreateStore(val, ptr)
 c.builder.CreateBr(storeDoneBlock)
 // this generated code runs if the write is &gt; WRAM range
 c.selectBlock(notInWRamBlock)
 x4000 := llvm.ConstInt(llvm.Int16Type(), 0x4000, false)
 inPpuRam := c.builder.CreateICmp(llvm.IntULT, addr, x4000, "")
 notInPpuRamBlock := c.createIf(inPpuRam)
 // this generated code runs if the write is in the PPU RAM range
 maskedAddr = c.builder.CreateAnd(addr, llvm.ConstInt(llvm.Int16Type(), 0x8-1, false), "")
 badPpuAddrBlock := c.createBlock("BadPPUAddr")
 sw := c.builder.CreateSwitch(maskedAddr, badPpuAddrBlock, 7)
 // this generated code runs if the write is in a bad PPU RAM addr
 c.selectBlock(badPpuAddrBlock)
 c.createPanic("invalid store address: $%04x\n", []llvm.Value{addr})

 ppuCtrlBlock := c.createBlock("ppuctrl")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 0, false), ppuCtrlBlock)
 c.selectBlock(ppuCtrlBlock)
 c.builder.CreateCall(c.ppuCtrlFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 ppuMaskBlock := c.createBlock("ppumask")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 1, false), ppuMaskBlock)
 c.selectBlock(ppuMaskBlock)
 c.builder.CreateCall(c.ppuMaskFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 oamAddrBlock := c.createBlock("oamaddr")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 3, false), oamAddrBlock)
 c.selectBlock(oamAddrBlock)
 c.builder.CreateCall(c.oamAddrFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 oamDataBlock := c.createBlock("oamdata")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 4, false), oamDataBlock)
 c.selectBlock(oamDataBlock)
 c.builder.CreateCall(c.setOamDataFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 ppuScrollBlock := c.createBlock("ppuscroll")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 5, false), ppuScrollBlock)
 c.selectBlock(ppuScrollBlock)
 c.builder.CreateCall(c.setPpuScrollFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 ppuAddrBlock := c.createBlock("ppuaddr")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 6, false), ppuAddrBlock)
 c.selectBlock(ppuAddrBlock)
 c.builder.CreateCall(c.ppuAddrFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 ppuDataBlock := c.createBlock("ppudata")
 sw.AddCase(llvm.ConstInt(llvm.Int16Type(), 7, false), ppuDataBlock)
 c.selectBlock(ppuDataBlock)
 c.builder.CreateCall(c.setPpuDataFn, []llvm.Value{val}, "")
 c.builder.CreateBr(storeDoneBlock)

 // this generated code runs if the write is &gt;= 0x4000
 // There are more cases to handle; here we only show
 // handling WRAM and the PPU.
 c.selectBlock(notInPpuRamBlock)
 c.createPanic()

 // done. X_X
 c.selectBlock(storeDoneBlock)
}

func (c *Compilation) createIf(cond llvm.Value) llvm.BasicBlock {
 // Create a conditional branch along with the 2 target blocks.
 // Returns the else block and set the current block to the then block.

 elseBlock := c.createBlock("else")
 thenBlock := c.createBlock("then")
 c.builder.CreateCondBr(cond, thenBlock, elseBlock)
 c.selectBlock(thenBlock)
 return elseBlock
}

func (c *Compilation) createBlock(name string) llvm.BasicBlock {
 bb := llvm.InsertBasicBlock(*c.currentBlock, name)
 bb.MoveAfter(*c.currentBlock)
 return bb
}

func (c *Compilation) selectBlock(bb llvm.BasicBlock) {
 c.builder.SetInsertPointAtEnd(bb)
 c.currentBlock = &bb
}

func (c *Compilation) createPanic() {
 bytePointerType := llvm.PointerType(llvm.Int8Type(), 0)
 ptr := c.builder.CreatePointerCast(c.runtimePanicMsg, bytePointerType, "")
 c.builder.CreateCall(c.putsFn, []llvm.Value{ptr}, "")
 exitCode := llvm.ConstInt(llvm.Int32Type(), 1, false)
 c.builder.CreateCall(c.exitFn, []llvm.Value{exitCode}, "")
 c.builder.CreateUnreachable()
}
</pre></div>

Let's take a look at what the IR code might look like for this instruction. First, a simplified assembly source file:

<div class="nul"><pre>
.org $c000

Reset_Routine:
    STA ($00), Y
    STA $2009 ; exit

NMI_Routine:
    RTI

IRQ_Routine:
    RTI

.org $fffa
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>

And then the LLVM module that would be generated, before optimizations:

<div class="nul"><pre>
; ModuleID = 'asm_module'

@wram = private global [2048 x i8] zeroinitializer
@panicMsg = private global [51 x i8] c"panic: attempted to write to invalid memory address"

declare i32 @putchar(i32)

declare i32 @puts(i8*)

declare void @exit(i32) noreturn nounwind

declare i8 @rom_ppu_read_status()

declare void @rom_ppu_write_control(i8)

declare void @rom_ppu_write_mask(i8)

declare void @rom_ppu_write_address(i8)

declare void @rom_ppu_write_data(i8)

declare void @rom_ppu_write_oamaddress(i8)

declare void @rom_ppu_write_oamdata(i8)

declare void @rom_ppu_write_scroll(i8)

define i32 @main() {
Entry:
  %X = alloca i8
  %Y = alloca i8
  %A = alloca i8
  %SP = alloca i8
  %S_neg = alloca i1
  %S_zero = alloca i1
  %S_dec = alloca i1
  %S_int = alloca i1
  br label %Reset_Routine

Reset_Routine:                                    ; preds = %Entry
  %0 = load i8* getelementptr inbounds ([2048 x i8]* @wram, i8 0, i8 0)
  %1 = load i8* getelementptr inbounds ([2048 x i8]* @wram, i8 0, i8 1)
  %2 = zext i8 %0 to i16
  %3 = zext i8 %1 to i16
  %4 = shl i16 %3, 8
  %5 = or i16 %4, %2
  %6 = load i8* %Y
  %7 = zext i8 %6 to i16
  %8 = add i16 %5, %7
  %9 = load i8* %A
  %10 = icmp ult i16 %8, 8192
  br i1 %10, label %then, label %else

then:                                             ; preds = %Reset_Routine
  %11 = and i16 %8, 2047
  %12 = getelementptr [2048 x i8]* @wram, i16 0, i16 %11
  store i8 %9, i8* %12
  br label %STA_done

else:                                             ; preds = %Reset_Routine
  %13 = icmp ult i16 %8, 16384
  br i1 %13, label %then2, label %else1

then2:                                            ; preds = %else
  %14 = and i16 %8, 7
  switch i16 %14, label %BadPPUAddr [
    i16 0, label %ppuctrl
    i16 1, label %ppumask
    i16 3, label %oamaddr
    i16 4, label %oamdata
    i16 5, label %ppuscroll
    i16 6, label %ppuaddr
    i16 7, label %ppudata
  ]

BadPPUAddr:                                       ; preds = %then2
  %15 = call i32 @puts(i8* getelementptr inbounds ([51 x i8]* @panicMsg, i32 0, i32 0))
  call void @exit(i32 1)
  unreachable

ppuctrl:                                          ; preds = %then2
  call void @rom_ppu_write_control(i8 %9)
  br label %STA_done

ppumask:                                          ; preds = %then2
  call void @rom_ppu_write_mask(i8 %9)
  br label %STA_done

oamaddr:                                          ; preds = %then2
  call void @rom_ppu_write_oamaddress(i8 %9)
  br label %STA_done

oamdata:                                          ; preds = %then2
  call void @rom_ppu_write_oamdata(i8 %9)
  br label %STA_done

ppuscroll:                                        ; preds = %then2
  call void @rom_ppu_write_scroll(i8 %9)
  br label %STA_done

ppuaddr:                                          ; preds = %then2
  call void @rom_ppu_write_address(i8 %9)
  br label %STA_done

ppudata:                                          ; preds = %then2
  call void @rom_ppu_write_data(i8 %9)
  br label %STA_done

else1:                                            ; preds = %else
  %16 = call i32 @puts(i8* getelementptr inbounds ([51 x i8]* @panicMsg, i32 0, i32 0))
  call void @exit(i32 1)
  unreachable

STA_done:                                         ; preds = %ppudata, %ppuaddr, %ppuscroll, %oamdata, %oamaddr, %ppumask, %ppuctrl, %then
  %17 = load i8* %A
  %18 = zext i8 %17 to i32
  call void @exit(i32 %18)
  br label %NMI_Routine

NMI_Routine:                                      ; preds = %STA_done
  unreachable

IRQ_Routine:                                      ; No predecessors!
  unreachable
}
</pre></div>

With this framework in place, we can recompile instructions that store to memory addresses only known at runtime. Code generation for the other instructions in this assembly program is straightforward at this point.
<P>
So now we can generate a new, native program to run. But how do we get the video to actually display on the screen? This question brings us to the next challenge.

</body>
</html>