<html><title>Optimization</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>
Did you notice that we never used the value of <code>S_neg</code>? We only ever stored it. This is a waste of CPU cycles. We can do better. However, we don't want to completely remove the ability to compute <code>S_neg</code><!--more--> - although this "Hello World" example does not use the value, other code might.
<P>
Optimization is an enormously complicated topic, with its own well-deserved field. Luckly, we won't have to wrap our heads around it in order to benefit. LLVM IR code is designed to be optimized. LLVM comes with state of the art optimization techniques, in the form of passes that you run on a module.
<div class="dir">
<a href="http://aondir.blogspot.com/search?q=Recompiling+NES+Games&amp;max-results=21">!Table of Contents More</a>
</div>
Let's run several optimization passes on the module we generate before rendering bitcode:

<div class="dir">
Optimization Name <a href="http://llvm.org/docs/Passes.html#constprop-simple-constant-propagation"><code>Constant Propagation</code></a> <b>Description:</b> Looks for instructions involving only constants and replaces them with a constant value instead of an instruction.
</div>

<div class="dir">
Optimization Name <a href="http://llvm.org/docs/Passes.html#instcombine-combine-redundant-instructions"><code>Combine Redundant Instructions</code></a> <b>Description:</b> Combines instructions to form fewer, simple instructions. For example if you add 1 twice, it will instead add 2.
</div>

<div class="dir">
Optimization Name <a href="http://llvm.org/docs/Passes.html#mem2reg-promote-memory-to-register"><code>Promote Memory to Register</code></a> <b>Description:</b> This pass allows us to load every "register" variable (X, Y, A, etc) before performing an instruction, and then store the register variable back after performing the instruction. This optimization pass will convert our allocated variables into registers, eliminating all the redundancy.
</div>

<div class="dir">
Optimization Name <a href="http://llvm.org/docs/Passes.html#gvn-global-value-numbering"><code>Global Value Numbering</code></a> <b>Description:</b> Eliminates partially and fully redundant instructions, and delete redundant load instructions.
</div>

<div class="dir">
Optimization Name <a href="http://llvm.org/docs/Passes.html#simplifycfg-simplify-the-cfg"><code>Control Flow Graph Simplification</code></a> <b>Description:</b> Removes unnecessary code and merges basic blocks together when possible.
</div>

Here's what it looks like to add these optimization passes to our <code>Compile</code> code:

<div class="nul"><pre>
// ...
 err := llvm.VerifyModule(c.mod, llvm.ReturnStatusAction)
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }

 // This creates an engine object which has useful information
 // about our machine as a target.
 engine, err := llvm.NewJITCompiler(c.mod, 3)
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }
 defer engine.Dispose()

 pass := llvm.NewPassManager()
 defer pass.Dispose()

 pass.Add(engine.TargetData())
 pass.AddConstantPropagationPass()
 pass.AddInstructionCombiningPass()
 pass.AddPromoteMemoryToRegisterPass()
 pass.AddGVNPass()
 pass.AddCFGSimplificationPass()
 pass.Run(c.mod)

 // Uncomment this to print the LLVM IR code we just generated
 // to stderr.
 //c.mod.Dump()

 // ...
</pre></div>

LLVM offers <a href="http://llvm.org/docs/Passes.html">many more available passes</a>, and it's up to the user to choose which ones, and in which order, to run. Let's see how the ones chosen in the table above perform on our "Hello World" code:

<div class="nul"><pre>
; ModuleID = 'asm_module'

@Label_c000 = private global [15 x i8] c"Hello, World!\0A\00"

declare i32 @putchar(i32)

declare void @exit(i32) noreturn nounwind

define i32 @main() {
Entry:
  br label %Label_c011

Label_c011:                                       ; preds = %else, %Entry
  %storemerge = phi i8 [ 0, %Entry ], [ %6, %else ]
  %0 = sext i8 %storemerge to i64
  %1 = getelementptr [15 x i8]* @Label_c000, i64 0, i64 %0
  %2 = load i8* %1, align 1
  %3 = icmp eq i8 %2, 0
  br i1 %3, label %Label_c01d, label %else

else:                                             ; preds = %Label_c011
  %4 = zext i8 %2 to i32
  %5 = call i32 @putchar(i32 %4)
  %6 = add i8 %storemerge, 1
  br label %Label_c011

Label_c01d:                                       ; preds = %Label_c011
  call void @exit(i32 0)
  unreachable
}
</pre></div>

Wow! The code looks completely different, and much simpler. But does it still run?

<div class="nul"><pre>
$ llc -filetype=obj hello.bc
$ gcc hello.bc.o
$ ./a.out
Hello, World!
$
</pre></div>

Sure does! Now, not only are we recompiling a simple 6502 program for native machine code, but we're actually generating highly optimized code. But it's not time to congratulate ourselves yet. This is a contrived case. Let's see if these techniques can work on an actual NES game.

</body>
</html>