<html><title>Test</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

You became giddy with excitement when I discovered LLVM. Generate code in LLVM IR format, and LLVM can optimize and generate native code for any of its supported backends. Here's an incomplete list<!--more-->:

<div class="dir"><pre>
ARM
STI CBEA Cell SPU [experimental]
C++ backend
Hexagon
MBlaze
Mips
Mips64 [experimental]
Mips64el [experimental]
Mipsel
MSP430 [experimental]
NVIDIA PTX 32-bit
NVIDIA PTX 64-bit
PowerPC 32
PowerPC 64
Sparc
Sparc V9
Thumb
32-bit X86: Pentium-Pro and above
64-bit X86: EM64T and AMD64
XCore
</pre></div>

Furthermore, you can write additional backends to support additional targets. For example, <a href="http://emscripten.org"><code>emscripten</code></a> provides a JavaScript backend.
<P>
To seal the deal, the LLVM project offers <a href="http://clang.llvm.org"><code>clang</code></a>, a C, C++, Objective C, and Objective C++ front-end for LLVM. This means that because of the way LLVM is designed, emscripten allows you to compile C, C++, Objective C, and Objective C++ code for the browser. Wow!
<P>
Just to show you how refreshing this technology is, have a look at the following C code:
<div class="nul"><pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main() {
    uint8_t foo = 0xf0;
    if (foo & 0x80 == 0x80) {
        for (int i = 1; i <= 10; ++i) {
            printf("%d\n", i);
        }
    }
}
</pre></div>

Simple enough. Assign <code>11110000 to foo</code>. If the highest bit is 1 (which it is), print the integers from 1 to 10.
<P>
Compiling with gcc with default settings, we get:

<div class="nul"><pre>
$ gcc test.c
test.c: In function ‘main’:
test.c:7:5: error: ‘for’ loop initial declarations are only allowed in C99 mode
test.c:7:5: note: use option -std=c99 or -std=gnu99 to compile your code
$
</pre></div>
Right, so default gcc doesn't have the nice things that <b>C99</b> brings. Let's try that again with <code>gcc -std=c99:</code>
<div class="nul"><pre>
$ c99 test.c
$ ./a.out
$
</pre></div>

<code>Okay</code>, so now it compiled and ran, but why didn't it print the integers from 1 to 10? Let's try compiling with clang and see what happens:

<div class="nul"><pre>
$ clang test.c
test.c:6:13: warning: & has lower precedence than ==; == will be evaluated
      first [-Wparentheses]
    if (foo & 0x80 == 0x80) {
            ^~~~~~~~~~~~~~
test.c:6:13: note: place parentheses around the '==' expression to silence
      this warning
    if (foo & 0x80 == 0x80) {
            ^
              (           )
test.c:6:13: note: place parentheses around the & expression to evaluate it
      first
    if (foo & 0x80 == 0x80) {
            ^
        (         )
1 warning generated.
$
</pre></div>

Aha! In C, <code>&</code> has lower precedence than <code>==</code>. In addition to outputting with fancy terminal colors, clang found the bug in our program and issued a warning. Once we fix that up and run the code again, we get the expected behavior.
<P>
Note: It has been shown to me that <code>gcc -Wall</code> produces a similar warning for the same code example here. I apologize for the bogus example. However, my point still stands. LLVM has a much better explanation of the philosophy and differences in error messages between clang and gcc.
<P>
There are many instances where cryptic gcc errors in your code are made clear by clang. In the words of my friend Josh Wolfe,

<div class="dir">
Clang makes gcc look like a rusty old grandpa.
</div>

This is exciting because clang is merely a front-end to LLVM. What this means is that if you generate LLVM IR code, you share the same code generation backend as clang. With this I felt that powerful optimization and wide target platform support were within my grasp. What if we could translate NES assembly code into LLVM IR code? We could completely, statically recompile NES games into native binaries. 


</body>
</html>
