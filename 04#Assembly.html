<html><title>Assembly</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

One tried and true method to parsing source code is to use a lexer to tokenize the source, and then a parser to turn the tokens into an Abstract Syntax Tree. From there we can process the AST and turn it into the 32KB binary payload.<!--more--> In Go land, this is straightforward thanks to nex, a lexer, and go tool yacc, a parser that is bundled with Go. 
<P>
Here is the parser code that can build an AST for our "Hello, World" example:

<div class="nul"><pre>
%{
package jamulator

import (
 "fmt"
 "strconv"
 "container/list"
)

// Define the structures that make up the abstract syntax tree.

// Example:
//     Label1234:
type LabelStatement struct {
 LabelName string
 Line int
}

// Example:
//     Label1234: BRK
type LabeledStatement struct {
 Label *LabelStatement
 Stmt interface{}
}

// Example:
//     .org $8000
type OrgPseudoOp struct {
 Value int
 Fill byte
 Line int
}

type InstructionType int
const (
 // Example:
 //     ADC #$44
 ImmediateInstruction InstructionType = iota

 // Example:
 //     INX
 ImpliedInstruction

 // Example:
 //     ADC Label1234, X
 DirectWithLabelIndexedInstruction

 // Example:
 //     ADC $44, X
 DirectIndexedInstruction

 // Example:
 //     ADC Label1234
 DirectWithLabelInstruction

 // Example:
 //     ADC $44
 DirectInstruction

 // Example:
 //     ADC ($44, X)
 IndirectXInstruction

 // Example:
 //     ADC ($44), Y
 IndirectYInstruction

 // Example:
 //     JMP ($81cc)
 IndirectInstruction
)

type Instruction struct {
 Type InstructionType
 OpName string
 Line int

 // not all fields are used by all instruction types.
 Value int
 LabelName string
 RegisterName string

 // filled in later
 OpCode byte
 Offset int
 Payload []byte
}

type DataStmtType int
const (
 // Example:
 //     .db $44
 ByteDataStmt DataStmtType = iota

 // Example:
 //     .dw Label1234
 WordDataStmt
)

type DataStatement struct {
 Type DataStmtType
 dataList *list.List
 Line int

 // filled in later
 Offset int
 Payload []byte
}


type IntegerDataItem int
type StringDataItem string
type LabelCall struct {
 LabelName string
}
type ProgramAst struct {
 List *list.List
}

// This is the root node of the abstract syntax tree.
var programAst ProgramAst
%}

// This instructs yacc how to generate a structure that will fit
// any data type that we need to use for a node.
%union {
 integer int
 str string
 list *list.List
 orgPsuedoOp *OrgPseudoOp
 node interface{}
}

// These are the nodes that we build based on other nodes and tokens.
%type &lt;list&gt; statementList
%type &lt;node&gt; statement
%type &lt;node&gt; instructionStatement
%type &lt;node&gt; dataStatement
%type &lt;list&gt; dataList
%type &lt;list&gt; wordList
%type &lt;node&gt; dataItem
%type &lt;orgPsuedoOp&gt; orgPsuedoOp
%type &lt;node&gt; numberExpr
%type &lt;node&gt; numberExprOptionalPound

// These are tokens that we will encounter when reading the output from
// the lexer.
%token &lt;str&gt; tokIdentifier
%token &lt;integer&gt; tokInteger
%token &lt;str&gt; tokQuotedString
%token tokEqual
%token tokPound
%token tokDot
%token tokComma
%token tokNewline
%token tokDataByte
%token tokDataWord
%token tokProcessor
%token tokLParen
%token tokRParen
%token tokDot
%token tokColon
%token tokOrg

%%

// An assembly program is defined as a statementList.

programAst : statementList {
 programAst = ProgramAst{$1}
}

// A statementList is defined as another statementList, plus a single
// statement, or simply as a statement. This creates a linked list
// of statements.
statementList : statementList tokNewline statement {
 if $3 == nil {
  $$ = $1
 } else {
  $$ = $1
  $$.PushBack($3)
 }
} | statement {
 if $1 == nil {
  $$ = list.New()
 } else {
  $$ = list.New()
  $$.PushBack($1)
 }
}

// This defines a statement, which can be many things.

statement : tokDot tokIdentifier instructionStatement {
 $$ = &LabeledStatement{
  &LabelStatement{"." + $2, parseLineNumber},
  $3,
 }
} | tokIdentifier tokColon instructionStatement {
 $$ = &LabeledStatement{
  &LabelStatement{$1, parseLineNumber},
  $3,
 }
} | orgPsuedoOp {
 $$ = $1
} | instructionStatement {
 $$ = $1
} | tokDot tokIdentifier dataStatement {
 $$ = &LabeledStatement{
  &LabelStatement{"." + $2, parseLineNumber},
   $3,
  }
} | tokIdentifier tokColon dataStatement {
 $$ = &LabeledStatement{
  &LabelStatement{$1, parseLineNumber},
  $3,
 }
} | dataStatement {
 $$ = $1
} | tokIdentifier tokColon {
 $$ = &LabelStatement{$1, parseLineNumber}
} | {
 // empty statement
 $$ = nil
}

dataStatement : tokDataByte dataList {
 $$ = &DataStatement{
  Type: ByteDataStmt,
  dataList: $2,
  Line: parseLineNumber,
 }
} | tokDataWord wordList {
 $$ = &DataStatement{
  Type: WordDataStmt,
  dataList: $2,
  Line: parseLineNumber,
 }
}

wordList : wordList tokComma numberExprOptionalPound {
 $$ = $1
 $$.PushBack($3)
} | numberExprOptionalPound {
 $$ = list.New()
 $$.PushBack($1)
}

dataList : dataList tokComma dataItem {
 $$ = $1
 $$.PushBack($3)
} | dataItem {
 $$ = list.New()
 $$.PushBack($1)
}

numberExpr : tokPound tokInteger {
 tmp := IntegerDataItem($2)
 $$ = &tmp
} | tokIdentifier {
 $$ = &LabelCall{$1}
}

numberExprOptionalPound : numberExpr {
 $$ = $1
} | tokInteger {
 tmp := IntegerDataItem($1)
 $$ = &tmp
}

dataItem : tokQuotedString {
 tmp := StringDataItem($1)
 $$ = &tmp
} | numberExprOptionalPound {
 $$ = $1
}

orgPsuedoOp : tokOrg tokInteger {
 $$ = &OrgPseudoOp{$2, 0xff, parseLineNumber}
} | tokOrg tokInteger tokComma tokInteger {
 if $4 &gt; 0xff {
  yylex.Error("ORG directive fill parameter must be a single byte.")
 }
 $$ = &OrgPseudoOp{$2, byte($4), parseLineNumber}
}

instructionStatement : tokIdentifier tokPound tokInteger {
 $$ = &Instruction{
  Type: ImmediateInstruction,
  OpName: $1,
  Value: $3,
  Line: parseLineNumber,
 }
} | tokIdentifier {
 $$ = &Instruction{
  Type: ImpliedInstruction,
  OpName: $1,
  Line: parseLineNumber,
 }
} | tokIdentifier tokIdentifier tokComma tokIdentifier {
 $$ = &Instruction{
  Type: DirectWithLabelIndexedInstruction,
  OpName: $1,
  LabelName: $2,
  RegisterName: $4,
  Line: parseLineNumber,
 }
} | tokIdentifier tokInteger tokComma tokIdentifier {
 $$ = &Instruction{
  Type: DirectIndexedInstruction,
  OpName: $1,
  Value: $2,
  RegisterName: $4,
  Line: parseLineNumber,
 }
} | tokIdentifier tokIdentifier {
 $$ = &Instruction{
  Type: DirectWithLabelInstruction,
  OpName: $1,
  LabelName: $2,
  Line: parseLineNumber,
 }
} | tokIdentifier tokInteger {
 $$ = &Instruction{
  Type: DirectInstruction,
  OpName: $1,
  Value: $2,
  Line: parseLineNumber,
 }
} | tokIdentifier tokLParen tokInteger tokComma tokIdentifier tokRParen {
 if $5 != "x" && $5 != "X" {
  yylex.Error("Register argument must be X.")
 }
 $$ = &Instruction{
  Type: IndirectXInstruction,
  OpName: $1,
  Value: $3,
  Line: parseLineNumber,
 }
} | tokIdentifier tokLParen tokInteger tokRParen tokComma tokIdentifier {
 if $6 != "y" && $6 != "Y" {
  yylex.Error("Register argument must be Y.")
 }
 $$ = &Instruction{
  Type: IndirectYInstruction,
  OpName: $1,
  Value: $3,
  Line: parseLineNumber,
 }
} | tokIdentifier tokLParen tokInteger tokRParen {
 $$ = &Instruction{
  Type: IndirectInstruction,
  OpName: $1,
  Value: $3,
  Line: parseLineNumber,
 }
}

%%
</pre></div>

And here is the lexer code that generates the tokens listed above:

<div class="nul"><pre>
/\.[dD][bB]/ {
 return tokDataByte
}
/\.[dD][wW]/ {
 return tokDataWord
}
/\.[oO][rR][gG]/ {
 return tokOrg
}
/"[^"\n]*"/ {
 t := yylex.Text()
 lval.str = t[1:len(t)-1]
 return tokQuotedString
}
/[a-zA-Z][a-zA-Z_.0-9]*/ {
 lval.str = yylex.Text()
 return tokIdentifier
}
/%[01]+/ {
 binPart := yylex.Text()[1:]
 n, err := strconv.ParseUint(binPart, 2, 16)
 if err != nil {
  yylex.Error("Invalid binary integer: " + binPart)
 }
 lval.integer = int(n)
 return tokInteger
}
/\$[0-9a-fA-F]+/ {
 hexPart := yylex.Text()[1:]
 n, err := strconv.ParseUint(hexPart, 16, 16)
 if err != nil {
  yylex.Error("Invalid hexademical integer: " + hexPart)
 }
 lval.integer = int(n)
 return tokInteger
}
/[0-9]+/ {
 n, err := strconv.ParseUint(yylex.Text(), 10, 16)
 if err != nil {
  yylex.Error("Invalid decimal integer: " + yylex.Text())
 }
 lval.integer = int(n)
 return tokInteger
}
/=/ {
 return tokEqual
}
/:/ {
 return tokColon
}
/#/ {
 return tokPound
}
/\./ {
 return tokDot
}
/,/ {
 return tokComma
}
/\(/ {
 return tokLParen
}
/\)/ {
 return tokRParen
}
/[ \t\r]/ {
 // ignore whitespace
}
/;[^\n]*\n/ {
 // ignore comments
 parseLineNumber += 1
 return tokNewline
}
/\n+/ {
 parseLineNumber += len(yylex.Text())
 return tokNewline
}
/./ {
 yylex.Error(fmt.Sprintf("Unexpected character: %q", yylex.Text()))
}

//

package jamulator

import (
 "strconv"
 "os"
 "fmt"
)

var parseLineNumber int
var parseFilename string
var parseErrors ParseErrors

type ParseErrors []string

func (errs ParseErrors) Error() string {
 return strings.Join(errs, "\n")
}

func Parse(reader io.Reader) (ProgramAst, error) {
 parseLineNumber = 1

 lexer := NewLexer(reader)
 yyParse(lexer)
 if len(parseErrors) &gt; 0 {
  return ProgramAst{}, parseErrors
 }
 return programAst, nil
}

func ParseFile(filename string) (ProgramAst, error) {
 parseFilename = filename

 fd, err := os.Open(filename)
 if err != nil { return ProgramAst{}, err }
 programAst, err := Parse(fd)
 err2 := fd.Close()
 if err != nil { return ProgramAst{}, err }
 if err2 != nil { return ProgramAst{}, err2 }
 return programAst, nil
}

func (yylex Lexer) Error(e string) {
 s := fmt.Sprintf("%s line %d %s", parseFilename, parseLineNumber, e)
 parseErrors = append(parseErrors, s)
}
</pre></div>

Let's demonstrate our ability to parse the source code by printing and inspecting the abstract syntax tree.

<div class="nul"><pre>
import (
 "fmt"
 "reflect"
 "os"
)

func astPrint(indent int, n interface{}) {
 for i := 0; i &gt; indent; i++ {
  fmt.Print(" ")
 }
 fmt.Println(reflect.TypeOf(n))
}

func (ast ProgramAst) Print() {
 for e := ast.List.Front(); e != nil; e = e.Next() {
  astPrint(0, e.Value)
  switch t := e.Value.(type) {
  case *LabeledStatement:
   astPrint(2, t.Label)
   astPrint(2, t.Stmt)
  case *DataStatement:
   for de := t.dataList.Front(); de != nil; de = de.Next() {
    astPrint(2, de.Value)
   }
  }
 }
}
func main() {
 programAst, err := jamulator.ParseFile("hello.asm")
 if err != nil {
  fmt.Fprintf(os.Stderr, "%s\n", err.Error())
  os.Exit(1)
 }
 programAst.Print()
}
</pre></div>

Now we need to compile this code. At this point, we can no longer rely on Go to build everything because we now have 2 generated Go files:

<div  class="dir">
Source File <code>asm6502.nex</code> and Generated File <code>asm6502.nn.go</code>
</div>

<div  class="dir">
Source File <code>asm6502.y</code> and Generated File <code>y.go</code>
</div>

The most straightforward way to build the project at this point is to use a Makefile. Simple enough:

<div class="nul"><pre>
build: jamulator/y.go jamulator/asm6502.nn.go
 go build -o jamulate main.go

jamulator/y.go: jamulator/asm6502.y
 go tool yacc -o jamulator/y.go -v /dev/null jamulator/asm6502.y

jamulator/asm6502.nn.go: jamulator/asm6502.nex
 ${GOPATH}/bin/nex -e jamulator/asm6502.nex

clean:
 rm -f jamulator/asm6502.nn.go
 rm -f jamulator/y.go
 rm -f jamulate

.PHONY: build clean
</pre></div>

Now we can build the project with one command:

<div class="nul"><pre>
$ make
go tool yacc -o jamulator/y.go -v /dev/null jamulator/asm6502.y
/home/andy/golang/bin/nex -e jamulator/asm6502.nex
go build -o jamulate main.go
</pre></div>

And, sure enough, when we run this code, we get a nice breakdown of the source:

<div class="nul"><pre>
$ ./jamulate
*jamulator.OrgPseudoOp
*jamulator.LabelStatement
*jamulator.DataStatement
  *jamulator.StringDataItem
  *jamulator.IntegerDataItem
  *jamulator.IntegerDataItem
*jamulator.LabelStatement
*jamulator.Instruction
*jamulator.LabelStatement
*jamulator.Instruction
*jamulator.Instruction
*jamulator.Instruction
*jamulator.Instruction
*jamulator.Instruction
*jamulator.LabelStatement
*jamulator.Instruction
*jamulator.Instruction
*jamulator.LabeledStatement
  *jamulator.LabelStatement
  *jamulator.Instruction
*jamulator.LabeledStatement
  *jamulator.LabelStatement
  *jamulator.Instruction
*jamulator.OrgPseudoOp
*jamulator.DataStatement
  *jamulator.LabelCall
*jamulator.DataStatement
  *jamulator.LabelCall
*jamulator.DataStatement
  *jamulator.LabelCall
</pre></div>

Once we have this AST, building a binary is a cinch:

<div class="dir">
1. Loop over the AST and compute the byte offset for each instruction.
</div>
<div class="dir">
2. Use the computed byte offsets to resolve the instructions with labels.
</div>
<div class="dir">
3. Final pass to write the payload to the disk.
</div>


</body>
</html>
