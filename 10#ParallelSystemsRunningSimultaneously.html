<html><title>Runtime Address Checks</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

To find out how to get something rendering on the screen, I looked at Fergulator - an already-working NES emulator written in Go. Fergulator correctly emulates Super Mario Brothers 1 as well as Zelda Title Screen Simulator, so it will certainly work for our purpose - understanding how the video gets onto the screen. 
 
The answer is easy to find in this well factored codebase. Looking at the main loop in machine.go, the core logic is revealed:

<div class="nul"><pre>
cycles = cpu.Step()

for i := 0; i &lt; 3*cycles; i++ {
 ppu.Step()
}

for i := 0; i &lt; cycles; i++ {
 apu.Step()
}
</pre></div>

The CPU runs one instruction and returns how many cycles the instruction took to run, and then the PPU is stepped for 3 times as many cycles, and the APU is stepped the same number of cycles as the CPU.
<P>
A problem presents itself here. Our recompiled code replaces the CPU stepping, but we still have the PPU and the APU code to reckon with. We can start by eliminating audio from the equation and dealing with sound later. But no matter how you spin it, the fact remains that the PPU and the CPU run independently of one another, and at differing speeds.
<P>
You can choose to recompile program code and run that as the main loop, but then after every instruction you must emulate the PPU for 3 times as many cycles as the instruction took. Or you can choose to run the PPU as the main loop, but then after the appropriate amount of cycles you must emulate the CPU for one instruction.
<P>

One of the systems must be emulated. This is how I solved the problem:

<div class="dir">
Have code generation call <code>rom_cycle</code>, an external function, after every instruction completes, passing the number of cycles the instruction took as a parameter.
</div>

<div class="dir">
Bundle in a runtime with the generated executable which implements <code>rom_cycle</code> and emulates the PPU for the appropriate amount of steps.
</div>

It is a shame that we have to do some amount of emulation in this project, where the goal is to statically recompile as much as possible. The solution to this challenge represents a slight compromise to the project's integrity. Yet we press on.

Given this solution, I ported the PPU code as well as the <a href="http://www.libsdl.org/">SDL</a> and <a href="http://www.opengl.org/">OpenGL</a> front-end code from Fergulator to a <a href="https://github.com/andrewrk/jamulator/tree/c9b4de0424d4dcc623f594be4a165685874713fa/runtime">small C runtime</a>, which is compiled with clang. Here is a snippet explaining the <code>rom_cycle and main</code> functions:

<div class="nul"><pre>
#include "rom.h"
#include "assert.h"
#include "ppu.h"
#include "SDL/SDL.h"
#include "GL/glew.h"

Ppu* p;

// This function is called by the generated module after every instruction.
void rom_cycle(uint8_t cycles) {
    // Check the SDL event loop and quit if the Close event occurs.
    flush_events();

    // Step the PPU for 3 times number of cycles that just finished.
    for (int i = 0; i &lt; 3 * cycles; ++i) {
        Ppu_step(p);
    }
}

// This function is our new main entry point. We rename the
// main rom entry point to `rom_start` so that we can call it
// from this function.
int main(int argc, char* argv[]) {
    // Create a new instance of the PPU emulator core.
    p = Ppu_new();

    // The PPU code will call `render` when there is a frame ready to display
    // on the screen. The `render` function performs the SDL and OpenGL
    // calls to render the frame to the window.
    p-&gt;render = &render;

    // Remember that in the generated rom module, we export the ROM mirroring
    // setting after reading it from the .nes file. Here we use it to configure
    // the nametable code.
    Nametable_setMirroring(&p-&gt;nametables, rom_mirroring);

    // We currently only support ROMs with 1 CHR bank.
    assert(rom_chr_bank_count == 1);

    // In the generated rom module, we have the CHR ROM data in memory, as well
    // as `rom_read_chr`, an exported function which will copy the data to a
    // pointer. We use that to initialize the video RAM.
    rom_read_chr(p-&gt;vram);

    // This does the SDL and OpenGL setup such as creating the display window.
    init_video();

    // Here we call into the main entry point to the recompiled ROM code.
    rom_start();

    // Free up memory associated with the PPU emulator instance.
    Ppu_dispose(p);
}

uint8_t rom_ppu_read_status() {
    return Ppu_readStatus(p);
}

void rom_ppu_write_control(uint8_t b) {
    Ppu_writeControl(p, b);
}

void rom_ppu_write_mask(uint8_t b) {
    Ppu_writeMask(p, b);
}

void rom_ppu_write_oamaddress(uint8_t b) {
    Ppu_writeOamAddress(p, b);
}

void rom_ppu_write_address(uint8_t b) {
    Ppu_writeAddress(p, b);
}

void rom_ppu_write_data(uint8_t b) {
    Ppu_writeData(p, b);
}

void rom_ppu_write_oamdata(uint8_t b) {
    Ppu_writeOamData(p, b);
}

void rom_ppu_write_scroll(uint8_t b) {
    Ppu_writeScroll(p, b);
}
</pre></div>

Notice that we include <code>rom.h</code>. This is a header file that defines the contract that the generated rom module will fulfill:

<div class="nul"><pre>
#include "stdint.h"

enum {
    ROM_MIRRORING_VERTICAL,
    ROM_MIRRORING_HORIZONTAL,
    ROM_MIRRORING_SINGLE_UPPER,
    ROM_MIRRORING_SINGLE_LOWER,
};

uint8_t rom_mirroring;
uint8_t rom_chr_bank_count;

// write the chr rom into dest
void rom_read_chr(uint8_t* dest);

// starts executing the PRG ROM.
// this function returns when the the program exits.
void rom_start();

// called after every instruction with the number of
// cpu cycles that have passed.
void rom_cycle(uint8_t);

// PPU hooks
uint8_t rom_ppu_read_status();
void rom_ppu_write_control(uint8_t);
void rom_ppu_write_mask(uint8_t);
void rom_ppu_write_oamaddress(uint8_t);
void rom_ppu_write_oamdata(uint8_t);
void rom_ppu_write_scroll(uint8_t);
void rom_ppu_write_address(uint8_t);
void rom_ppu_write_data(uint8_t);
</pre></div>

When we build the final executable file, we can link against this runtime to get a fully operational executable with a video display.
<P>
After adding runtime compilation instructions, <code>make</code> does this:

<div class="nul"><pre>
$ make
go tool yacc -o jamulator/y.go -v /dev/null jamulator/asm6502.y
/home/andy/gocode/bin/nex -e jamulator/asm6502.nex
clang -o runtime/main.o -c runtime/main.c
clang -o runtime/ppu.o -c runtime/ppu.c
clang -o runtime/nametable.o -c runtime/nametable.c
ar rcs runtime/runtime.a runtime/main.o runtime/ppu.o runtime/nametable.o
go build -o jamulate main.go
$
</pre></div>

Next we can implement a command which will read a .nes ROM file and perform the recompilation process:

<div class="nul"><pre>
$ ./jamulate -recompile roms/Zelda.NES
loading roms/Zelda.NES
Disassembling...
Decompiling to /tmp/302858262/prg.bc...
llc -o /tmp/302858262/prg.o -filetype=obj /tmp/302858262/prg.bc
gcc /tmp/302858262/prg.o runtime/runtime.a -lGLEW -lGL -lSDL -lSDL_gfx -o roms/Zelda
Done: roms/Zelda
$ file ./roms/Zelda
./roms/Zelda: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0xa79ee93a78a4745b60ba9d10a58b209d756e8ffa, not stripped
$
</pre></div>

And so here we have it: an executable binary that depends on SDL and OpenGL, which supposedly will execute the Zelda Title Screen Simulator when run. Does it work?
<P>
Note: There is an obvious discrepancy between the screenshot and the output listed above. All output is real; the difference is that the article is organized, ordered, and simplified for clarity and understanding. I did not necessarily write the code in the same order that it is listed in this article.
<P>
So we made a small concession to solve this challenge, and we have a simple demo NES ROM running natively. Next let's see if we can fix the dent in that sword.


</body>
</html>
