<html><title>Disassembly</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

Now we need to work backwards - we have the binary payload and we want to get the source. There is a challenge here. Remember that in assembly programs, we can insert arbitrary data with .db or .dw statements alongside instructions.<!--more--> In order to disassemble effectively, we have to be able to figure out what is "data" and what is "code".

<div class="dir">
<a href="http://aondir.blogspot.com/search?q=Recompiling+NES+Games&amp;max-results=21">!Table of Contents More</a>
</div>

One possible technique is to emulate the assembly program, and then record the ways in which memory addresses are accessed. After playing a game for a while, you would have a pretty good record of exactly which sections are data and which are code. I decided not to use this technique, however, since the goal of this project is static recompilation. I want to explore just how much is possible to do at compile-time.

<b>So what can we do?</b> First, recall that the last 6 bytes in NES programs are 3 memory addresses which are the 3 entry points into the program:

<div class="nul"><pre>
.org $fffa
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>

Given this, a workable strategy becomes clear:

<div class="dir">
1. Create an AST where every single byte is a single <code>.db</code> statement.
</div>

<div class="dir">
2. Replace the <code>.db</code> statements at <code>$fffa and $fffb</code> with a .dw statement which references an <code>NMI_Routine</code> label.
</div>

<div class="dir">
3. Calculate the address that the <code>.db</code> statements at <code>$fffa and $fffb</code> were referring to, and insert a <code>LabelStatement</code> with the <code>NMI_Routine</code> label before the <code>.db</code> statement at that address.
</div>

<div class="dir">
4. Mark the <code>.db</code> statement at that address as an instruction.
</div>

When I say "mark as an instruction", what I mean is that we should interpret the <code>.db</code> statement at that location as an op code, and then use that to replace the following <code>.db</code> statements as part of the instruction as necessary. Then, based on the instruction, we want to recursively mark other locations as instructions:

<div class="dir">
Instruction <code>BPL, BMI, BVC, BVS, BCC, BCS, BNE, BEQ, JSR</code> <b>What to Do:</b> Mark the jump target address and the next address as an instruction.
</div>

<div class="dir">
Instruction <code>JMP absolute</code> <b>What to Do:</b> Mark the jump target address as an instruction.
</div>

<div class="dir">
Instruction <code>RTI, RTS, BRK, JMP indirect</code> <b>What to Do:</b> Do nothing.
</div>

<div class="dir">
Instruction <code>everything else</code> <b>What to Do:</b> Mark the next address as an instruction.
</div>

The instructions that start with "B" are all conditional branch instructions. This means that they test some condition, and then either transfer control flow to the next instruction, or to a different label. This means that we can mark the possible branch address and the next address as instructions.
<P>
<code>JSR</code> stands for "Jump to SubRoutine". This will transfer control to a target address and then later when the <code>RTS</code> ("ReTurn from Subroutine") instruction is reached, continue execution where the <code>JSR</code> instruction left off.
<P>
It is possible for assembly programmers to use <code>JSR</code> and then inside the subroutine, do tricks with the stack to return to a different location. This is a problem that will be tackled later. It's not an issue with our "Hello World" example.
<P>
<code>RTI, RTS, and BRK</code> modify control flow, but the destination address is not constant, so these instructions do not help us know what else to mark as instructions.
<P>
As seen in this table, there are 2 types of <code>JMP</code> instructions: absolute and indirect:

<div class="dir">
JMP Type <code>Absolute</code> Example Assembly <code>JMP Label_80a2</code> <b>Description:</b> This version is used in the "Hello World" program. It sends control flow to the operand address - which in this example is a label. This version is convenient for disassembly because the destination address is known statically - the address is hard-coded.
</div>

<div class="dir">
JMP Type <code>Indirect</code> Example Assembly <code>JMP ($0123)</code> <b>Description:</b> Uses the operand address as a pointer, sending control flow to the address at the pointer. This will prove to be one of the big challenges of this project. More on this later.
</div>

The instructions in the earlier table are the only ones that modify control flow. All other instructions execute serially. Thus if we encounter one of these, we can reliably decode the next byte as an instruction.
<P>
Here's what it looks like when we apply this algorithm to our Hello World binary code:

<div class="nul"><pre>
.org $8000
Label_8000:
    .db $48
    .db $65
    .db $6c
    .db $6c
    .db $6f
    .db $2c
    .db $20
    .db $57
    .db $6f
    .db $72
    .db $6c
    .db $64
    .db $21
    .db $0a
    .db $00
Reset_Routine:
    LDX #$00
Label_8011:
    LDA Label_8000, X
    BEQ Label_801d
    STA $2008
    INX
    JMP Label_8011
Label_801d:
    LDA #$00
    STA $2009
IRQ_Routine:
    RTI
NMI_Routine:
    RTI
    .db $ff

    ...
    (this is repeated about 30,000 times)
    ...

    .db $ff
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>

This technique was able to decode all of the instructions, but we can't read the text, and it's pretty annoying having <code>$ff</code> - the filler byte value - repeated so many times. Let's add a pass to detect ASCII strings. We can do this by counting how many characters in a <code>.db</code> statement in a row are considered "ASCII" and when a threshold of 4 is reached, replace the <code>.db</code> statements with a quoted string:

<div class="nul"><pre>
.org $8000
Label_8000:
    .db "Hello, World!"
    .db $0a
    .db $00
Reset_Routine:
    LDX #$00
Label_8011:
    LDA Label_8000, X
    BEQ Label_801d
    STA $2008
    INX
    JMP Label_8011
Label_801d:
    LDA #$00
    STA $2009
IRQ_Routine:
    RTI
NMI_Routine:
    RTI
    .db $ff
    .db $ff

    ...
    (repeated about 30,000 times)
    ...

    .db $ff
    .db $ff
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>
Better! Let's solve the problem of the repeating <code>$ff</code> by adding a pass to detect where it would make sense to place <code>.org</code> statements. We can do this in much the same way as ASCII detection, but in this case we will look out for repeating bytes rather than bytes which fit in the ASCII range. 64 seems like a good threshold. If a byte repeats 64 times, replace all the repeated occurences with a <code>.org</code> statement:

<div class="nul"><pre>
.org $8000
Label_8000:
    .db "Hello, World!"
    .db $0a
    .db $00
Reset_Routine:
    LDX #$00
Label_8011:
    LDA Label_8000, X
    BEQ Label_801d
    STA $2008
    INX
    JMP Label_8011
Label_801d:
    LDA #$00
    STA $2009
IRQ_Routine:
    RTI
NMI_Routine:
    RTI
.org $fffa
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>
And finally, one minor detail. Let's do a final pass to collapse <code>.db</code> statements together:

<div class="nul"><pre>
.org $8000
Label_8000:
    .db "Hello, World!", $0a, $00
Reset_Routine:
    LDX #$00
Label_8011:
    LDA Label_8000, X
    BEQ Label_801d
    STA $2008
    INX
    JMP Label_8011
Label_801d:
    LDA #$00
    STA $2009
IRQ_Routine:
    RTI
NMI_Routine:
    RTI
.org $fffa
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>

Not bad. This is as close as we can get to the original source. It's impossible to know what label names were used, but we can give good names to the interrupt vectors. We just turned a binary machine code program into human-readable assembly.
<P>
Now that we can figure out the assembly source code from 6502 machine code, we can start the fun part - converting the assembly program into native machine code.



</body>
</html>