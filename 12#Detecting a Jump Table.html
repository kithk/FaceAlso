<html><title>Detecting a Jump Table</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

Here's a small section of Super Mario Brothers 1 disassembly:

<div class="nul"><pre>
Label_8212:
    LDA $0770
    JSR Label_8e04
    AND ($82), Y
    .db $dc, $ae, $8b, $83, $18, $92
</pre></div>

Notice anything peculiar? After the value at <acode>$0770</code> is loaded into register A, and we return from the <code>Label_8e04</code> subroutine, there is an uncommon indirect <code>AND</code> instruction, followed by data. What could possibly be happening here? Super Mario Brothers 1 is using a common assembly programming technique called a dynamic jump table. Take a look at the <code>Label_8e04</code> subroutine:

<div class="nul"><pre>
Label_8e04:
    ASL
    TAY
    PLA
    STA $04
    PLA
    STA $05
    INY
    LDA ($04), Y
    STA $06
    INY
    LDA ($04), Y
    STA $07
    JMP ($0006)
</pre></div>

Notice that although this label is jumped to with <code>JSR</code>, it never uses the <code>RTS</code> instruction. Let's break it down further into readable pseudocode:

<div class="nul"><pre>
; Dynamic Jump Table. Call this label with JSR
; so that the old PC is on the stack.
; Immediately following the JSR statement should be
; .dw statements indicating the labels to jump to
; depending on the value of register A.
Label_8e04:
    ; Register A holds the index of the label that we wish to jump to.
    ; Multiply A by 2 because each table entry is 2 bytes.
    ASL           ; A = A * 2

    ; The useful indirect instructions use Y as the index, and we need
    ; to repurpose A.
    TAY           ; Y = A

    ; Since this label was called with JSR, the old PC is on the top
    ; of the stack. Here we get the lower byte since this is a little
    ; endian system.
    PLA           ; A = Stack.Pop()

    ; Save the lower byte of the old PC into memory.
    STA $04       ; Memory[$04] = A

    ; Get the higher byte of the old PC off the stack.
    PLA           ; A = Stack.Pop()

    ; Save the higher byte of the old PC into memory.
    STA $05       ; Memory[$05] = A

    ; JSR pushes the address - 1 of the next instruction to the stack.
    ; So we add 1 to Y to get the index of the first byte of the jump
    ; destination.
    INY           ; Y = Y + 1

    ; Get the first byte of the jump destination.
    LDA ($04), Y  ; A = Memory[Memory[$04] + Y]

    ; Save the first byte of the jump destination.
    STA $06       ; Memory[$06] = A

    ; Increment Y to get the index of the 2nd byte of the jump destination.
    INY           ; Y = Y + 1

    ; Get the 2nd byte of the jump instruction.
    LDA ($04), Y  ; A = Memory[Memory[$04] + Y]

    ; Save the 2nd byte of the jump instruction.
    STA $07       ; Memory[$07] = A

    ; Jump to the location that was just constructed.
    JMP ($0006)     ; Jump to address at $0006 - $0007
</pre></div>

If we know that <code>Label_8e04</code> is a jump table, we can mark the bytes following the JSR as .dw labels which enables us to further disassemble the program. The disassembled snippet from earlier would look like this:

<div class="nul"><pre>
Label_8212:
    LDA $0770
    JSR Label_8e04
    .dw Label_8231
    .dw Label_aedc
    .dw Label_838b
    .dw Label_9218
</pre></div>

Without this jump table detection, the bytes at each of those labels remain <code>.db</code> statements, unable to be decoded. This is problematic because our strategy currently depends on all instructions being completely disassembled so that they can be decompiled and recompiled.
<P>
This is not a mere corner-case either. This technique is repeated in many games, including <a href="http://sonicepoch.com/sm3mix/disassembly.html#DynJump">Super Mario Brothers 3</a> and Pac-Man.
<P>
Fortunately, it is straightforward to identify and process a jump table like this without changing too much code. I solved it with a state machine - essentially pattern-matching or a regular expression for instructions:

<div class="nul"><pre>
func (d *Disassembly) detectJumpTable(addr int) bool {
 const (
  expectAsl = iota
  expectTay
  expectPlaA
  expectStaA
  expectPlaB
  expectStaB
  expectInyC
  expectLdaC
  expectStaC
  expectInYD
  expectLdaD
  expectStaD
  expectJmp
 )
 state := expectAsl
 var memA, memC int
 for elem := d.prog.elemAtAddr(addr); elem != nil; elem = elem.Next() {
  switch state {
  case expectAsl:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x0a {
    return false
   }
   state = expectTay
  case expectTay:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0xa8 {
    return false
   }
   state = expectPlaA
  case expectPlaA:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x68 {
    return false
   }
   state = expectStaA
  case expectStaA:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x85 && i.OpCode != 0x8d {
    return false
   }
   memA = i.Value
   state = expectPlaB
  case expectPlaB:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x68 {
    return false
   }
   state = expectStaB
  case expectStaB:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x85 && i.OpCode != 0x8d {
    return false
   }
   if i.Value != memA+1 {
    return false
   }
   state = expectInyC
  case expectInyC:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0xc8 {
    return false
   }
   state = expectLdaC
  case expectLdaC:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0xb1 {
    return false
   }
   if i.Value != memA {
    return false
   }
   state = expectStaC
  case expectStaC:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x85 && i.OpCode != 0x8d {
    return false
   }
   memC = i.Value
   state = expectInYD
  case expectInYD:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0xc8 {
    return false
   }
   state = expectLdaD
  case expectLdaD:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0xb1 {
    return false
   }
   if i.Value != memA {
    return false
   }
   state = expectStaD
  case expectStaD:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x85 && i.OpCode != 0x8d {
    return false
   }
   if i.Value != memC+1 {
    return false
   }
   state = expectJmp
  case expectJmp:
   i, ok := elem.Value.(*Instruction)
   if !ok {
    return false
   }
   if i.OpCode != 0x6c {
    return false
   }
   if i.Value != memC {
    return false
   }
   return true
  }
 }
 return false
}
</pre></div>

Given this detection function, it is a matter of adding logic to the <code>JSR</code> disassembly. If a jump table is detected, mark the following bytes as <code>.dw</code> label statements. Otherwise, continue marking the next address as an instruction as usual. After adding jump table detection, it looks like all the program instructions are disassembled successfully. But there are still some tricks up the assembly programmers' sleeves.

</body>
</html>
