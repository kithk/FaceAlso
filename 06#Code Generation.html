<html><title>Code Generation</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

Our code generation code will generate an LLVM bitcode module. We can then use <code>llc</code> to compile the bitcode into an object file, the same as if we used <code>gcc -c module.c</code> and looked at the resulting <code>module.o</code>.<!--more-->
<p>
LLVM is written in C++, but it also exposes a C interface. This means we can integrate cleanly using cgo. In fact, Andrew Wilkins maintains a convenient Go module called gollvm which gives us seamless integration.

<div class="dir">
<a href="http://aondir.blogspot.com/search?q=Recompiling+NES+Games&amp;max-results=21">!Table of Contents More</a>
</div>

At any time we can debug the LLVM module we are generating by calling <code>module.Dump()</code> which prints the LLVM IR code for the module to stderr. Let's start by manually creating the IR code that we want to generate for Hello World, so we know what to work toward. We can get a head start by writing it in C and using <code>clang</code> to generate the IR code for us:

<div class="nul"><pre>
#include <stdio.h>

char * msg = "Hello, World!\n";

int main() {
    char * ptr = msg;
    while (*ptr) {
        putchar(*ptr);
        ++ptr;
    }
}
</pre></div>
<div class="nul"><pre>
$ clang -emit-llvm -S test.c
$
</pre></div>
Now looking at test.s:

<div class="nul"><pre>
; ModuleID = 'test.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

@.str = private unnamed_addr constant [15 x i8] c"Hello, World!\0A\00", align 1
@msg = global i8* getelementptr inbounds ([15 x i8]* @.str, i32 0, i32 0), align 8

define i32 @main() nounwind uwtable {
  %1 = alloca i32, align 4
  %ptr = alloca i8*, align 8
  store i32 0, i32* %1
  %2 = load i8** @msg, align 8
  store i8* %2, i8** %ptr, align 8
  br label %3

; &lt;label&gt;:3                                       ; preds = %7, %0
  %4 = load i8** %ptr, align 8
  %5 = load i8* %4, align 1
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %7, label %14

; &lt;label&gt;:7                                       ; preds = %3
  %8 = load i8** %ptr, align 8
  %9 = load i8* %8, align 1
  %10 = sext i8 %9 to i32
  %11 = call i32 @putchar(i32 %10)
  %12 = load i8** %ptr, align 8
  %13 = getelementptr inbounds i8* %12, i32 1
  store i8* %13, i8** %ptr, align 8
  br label %3

; &lt;label&gt;:14                                      ; preds = %3
  %15 = load i32* %1
  ret i32 %15
}

declare i32 @putchar(i32)
</pre></div>

Alright - that looks a bit different than the code we're going to generate, but it's a good start. If that looks complicated, don't worry - we're going to do 3 things to make it less so:

<div class="dir">
1. Read up on the <a href="http://llvm.org/docs/LangRef.html">language reference</a>.
</div>

<div class="dir">
2. Delete the stuff that seems unnecessary and see if it still works.
</div>

<div class="dir">
3. Modify the code to look like what we want to generate.
</div>

Here's an updated version with inline comments breaking it down:

<div class="nul"><pre>
; Here we declare the text that we will print.

; "private" means that only this module can see it - we do not export this
; symbol. Always declare private when possible. There are optimizations to be
; had when a symbol is not exported.

; "constant" means that this data is read-only. Again use constant when
; possible so that optimization passes can take advantage of this fact.

; [15 x i8] is the type of this data. i8 means an 8-bit integer.
@msg = private constant [15 x i8] c"Hello, World!\0a\00"


; Here we declare a dependency on the `putchar` symbol.

; When this module is linked, `putchar` must be defined somewhere, and with
; this signature.
declare i32 @putchar(i32)


; Same thing for `exit`.

; `noreturn` indicates that we do not expect this function to return. It will
; end the process, after all.

; `nounwind` has to do with LLVM's error handling model. We use `nounwind`
; because we know that `exit` will not throw an exception.
declare void @exit(i32) noreturn nounwind


; Note that we will be performing the final link step with gcc, which will
; automatically statically link against libc. This will provide the `putchar`
; and `exit` symbols, as well as set up the executable entry point to call `main`.
define i32 @main() {

; This label statement indicates the start of a basic block.
Entry:

; Here we allocate some variables on the stack. These are X, Y, and A,
; 3 of the 6502's 8-bit registers.
      %X = alloca i8
      %Y = alloca i8
      %A = alloca i8

; Note that here we are allocating variables which are single bits.
; These represent 2 of the bits from the status register.
; After this source listing there is a table explaining each bit
; of the status register.
      %S_neg = alloca i1
      %S_zero = alloca i1

; Send control flow to the Reset_Routine basic block.
      br label %Reset_Routine

Reset_Routine:

; This is the code to generate for
; LDX #$00

  ; Store 0 in the X register.
      store i8 0, i8* %X

  ; Clear the negative status bit, because we just stored 0 in X,
  ; and 0 is not negative.
      store i1 0, i1* %S_neg

  ; Set the zero status bit, because we just stored 0 in X.
      store i1 1, i1* %S_zero


      br label %Label_loop

Label_loop:

; This is the code to generate for
; LDA msg, X

  ; Load the value of X into %0.
      %0 = load i8* %X

  ; Get a pointer to the character in msg indexed by %0, which contains the
  ; value of X.
      %1 = getelementptr [15 x i8]* @msg, i64 0, i8 %0

  ; Read a byte of memory located at the pointer we just computed into %2.
      %2 = load i8* %1

  ; Store the byte we just loaded into %A, which is the variable we have
  ; allocated for A.
      store i8 %2, i8* %A

  ; Now we need to set the negative status bit correctly.

  ; The byte of memory we just loaded into %A is negative if
  ; and only if the highest bit is set.

  ; Perform a bitwise AND with 1000 0000.
      %3 = and i8 128, %2

  ; Test if the result is equal to 1000 0000.
      %4 = icmp eq i8 128, %3

  ; Save the answer to the negative status bit.
      store i1 %4, i1* %S_neg

  ; Now we need to set the zero status bit correctly.

  ; Test if the byte is equal to zero.
      %5 = icmp eq i8 0, %2

  ; Store the answer to the zero status bit.
      store i1 %5, i1* %S_zero


; This is the code to generate for
; BEQ loopend
      %6 = load i1* %S_zero

  ; If zero bit is set, go to Label_loopend. Otherwise, go to AutoLabel_0
      br i1 %6, label %Label_loopend, label %AutoLabel_0

AutoLabel_0:

; This is the code to generate for
; STA $2008
      %7 = load i8* %A

  ; Convert the 8-bit integer that we just loaded from A into
  ; a 32-bit integer to match the signature of `putchar`.
      %8 = zext i8 %7 to i32

      %9 = call i32 @putchar(i32 %8)
      br label %AutoLabel_1
AutoLabel_1:
; This is the code to generate for
; INX
      %10 = load i8* %X
      %11 = add i8 %10, 1
      store i8 %11, i8* %X

  ; Set the negative status bit correctly.
      %12 = and i8 128, %11
      %13 = icmp eq i8 128, %12
      store i1 %13, i1* %S_neg

  ;Set the zero status bit correctly.
      %14 = icmp eq i8 0, %11
      store i1 %14, i1* %S_zero

; This is the code to generate for
; JMP loop
      br label %Label_loop

Label_loopend:
; This is the code to generate for
; LDA #$00

      store i8 0, i8* %A

      ; Clear the negative status bit.
      store i1 0, i1* %S_neg

      ; Set the zero status bit.
      store i1 1, i1* %S_zero

; This is the code to generate for
; STA $2009
      %15 = load i8* %A
      %16 = zext i8 %15 to i32
      call void @exit(i32 %16) noreturn nounwind

  ; Terminate this basic block with `unreachable` because
  ; exit never returns.
      unreachable

; Generate dummy basic blocks for the
; interrupt vectors, because we don't support them yet.
IRQ_Routine:
      unreachable

NMI_Routine:
      unreachable
}
</pre></div>

In this code we use <code>S_neg and S_zero</code>, 2 of the status register bits. These bits, along with the other status bits that we did not mention yet, are updated after certain instructions and used for things such as branching. Here is a full description of all the status bits:

<div class="dir">
Bit Mask <code></code>  Variable Name
</div>

<div class="dir">
Bit Mask <code>0000 0001</code> Variable Name <code>S_carry</code> <b>Description:</b> Used for arithmetic and bitwise instructions, typically to make it easier to deal with integers that are larger than 8 bits. We don't need to deal with this yet. <code>BCC and BCS</code> use this status bit to decide whether to branch.
</div>

<div class="dir">
Bit Mask <code>0000 0010</code> Variable Name <code>S_zero</code> <b>Description:</b> When a computation results in a value that is equal to zero, this status bit is set. Otherwise, it is cleared. <code>BEQ and BNE</code> use this status bit to decide whether to branch.
</div>

<div class="dir">
Bit Mask <code>0000 0100</code> Variable Name <code>S_int</code> <b>Description:</b> This bit indicates whether interrupts are disabled. You can use <code>SEI</code> to set this bit, and <code>CLI</code> to clear this bit. More on interrupts later.
</div>

<div class="dir">
Bit Mask <code>0000 1000</code> Variable Name <code>S_dec</code> <b>Description:</b> Normally, this bit would toggle decimal mode on and off. However, the NES disables this feature of the CPU, so it effectively does nothing. You can use <code>SED</code> to set this bit, and <code>CLD</code> to clear this bit.
</div>

<div class="dir">
Bit Mask <code>0001 0000</code> Variable Name <code>S_brk</code> <b>Description:</b> This bit is set when a <code>BRK</code> instruction has been executed and an interupt has been generated to process it. We'll ignore this bit for now.
</div>

<div class="dir">
Bit Mask <code>0010 0000</code> Variable Name <code>-</code> <b>Description:</b> This bit is unused. It remains 0 at all times.
</div>

<div class="dir">
Bit Mask <code>0100 0000</code> Variable Name <code>S_over</code> <b>Description:</b> When a computation results in an invalid <a href="https://en.wikipedia.org/wiki/Two's_complement">two's complement</a> value, this bit is set. Otherwise, it is cleared. <code>BVC and BVS</code> use this to decide whether to branch.
</div>

<div class="dir">
Bit Mask <code>1000 0000</code> Variable Name <code>S_neg</code> <b>Description:</b> When a computation results in a negative two's complement value, this bit is set. Otherwise, it is cleared. <code>BPL and BMI</code> use this status bit to decide whether to branch.
</div>

Let's make sure our goal LLVM code does what we expect:

<div class="nul"><pre>
$ llc -filetype=obj hello.llvm
$ gcc hello.llvm.o
$ ./a.out
Hello, World!
$
</pre></div>

<code>llc</code> converts the LLVM IR code into a native object file, and then <code>gcc</code> does the final link step, statically linking against libc to hook up <code>main, putchar, and exit</code>. By default, <code>gcc</code> creates an executable named <code>a.out</code>, which we run, and viola!
<P>
The next step is to generate this code from our disassembly. With the help of <a href="https://github.com/axw/gollvm">gollvm</a> you will:

<div class="dir">
1. Create a LLVM module.
</div>

<div class="dir">
2. Declare our dependency on <code>putchar and exit</code>.
</div>

<div class="dir">
3. Create the <code>main</code> function and allocate stack variables for the registers.
</div>

<div class="dir">
4. Perform one pass over the AST to identify labeled data and create global variables. We save the index of label name to global variable in a map.
</div>

<div class="dir">
5. Perform a second pass over the AST to generate the basic blocks and save an index of label name to basic block in a map.
</div>

<div class="dir">
6. Final pass over the AST to generate code inside of the basic blocks.
</div>

Here is a structure that contains the state we need while compiling:

<div class="dir"><pre>
type Compilation struct {
 // Keep track of the warnings and errors
 // that occur while compiling.
 Warnings []string
 Errors   []string

 // program is our abstract syntax tree -
 // we will make several passes over it during
 // the compilation process.
 program   *Program

 // LLVM variable which represents the module we
 // are creating.
 mod       llvm.Module

 // This is the object that we will use to do all the
 // code generation. It's used to create every kind
 // of statement.
 builder   llvm.Builder

 // Reference to our main function.
 mainFn    llvm.Value

 // References to the functions we declared, so we
 // can call them.
 putCharFn llvm.Value
 exitFn    llvm.Value

 // References to the variables we allocate on the stack
 // so we can use them in instructions.
 rX        llvm.Value
 rY        llvm.Value
 rA        llvm.Value
 rSNeg     llvm.Value
 rSZero    llvm.Value

 // Maps label name to the global variables that we add,
 // for when the code loads data from a label.
 labeledData   map[string]llvm.Value

 // Maps label name to basic block, so that when
 // code branches to another label, we can branch to
 // the relevant basic block.
 labeledBlocks map[string]llvm.BasicBlock

 // Keeps track of the basic block we are currently
 // generating code for, if any.
 currentBlock *llvm.BasicBlock

 // Keeps a reference to the reset routine basic block
 // so we know where to first jump to from the entry point.
 resetBlock     *llvm.BasicBlock
}
</pre></div>

With this structure, we can execute our plan:

<div class="dir"><pre>
func (p *Program) Compile(filename string) (c *Compilation) {
 llvm.InitializeNativeTarget()

 c = new(Compilation)
 c.program = p
 c.Warnings = []string{}
 c.Errors = []string{}
 c.mod = llvm.NewModule("asm_module")
 c.builder = llvm.NewBuilder()
 defer c.builder.Dispose()
 c.labeledData = map[string]llvm.Value{}
 c.labeledBlocks = map[string]llvm.BasicBlock{}

 // First pass to identify labeled data and create
 // global variables, saving the indexes in `c.labeledData`.
 c.identifyLabeledDataPass()

 // declare i32 @putchar(i32)
 i32Type := llvm.Int32Type()
 putCharType := llvm.FunctionType(i32Type, []llvm.Type{i32Type}, false)
 c.putCharFn = llvm.AddFunction(c.mod, "putchar", putCharType)
 c.putCharFn.SetLinkage(llvm.ExternalLinkage)

 // declare void @exit(i32) noreturn nounwind
 exitType := llvm.FunctionType(llvm.VoidType(), []llvm.Type{i32Type}, false)
 c.exitFn = llvm.AddFunction(c.mod, "exit", exitType)
 c.exitFn.AddFunctionAttr(llvm.NoReturnAttribute | llvm.NoUnwindAttribute)
 c.exitFn.SetLinkage(llvm.ExternalLinkage)

 // main function / entry point
 mainType := llvm.FunctionType(i32Type, []llvm.Type{}, false)
 c.mainFn = llvm.AddFunction(c.mod, "main", mainType)
 c.mainFn.SetFunctionCallConv(llvm.CCallConv)
 entry := llvm.AddBasicBlock(c.mainFn, "Entry")
 c.builder.SetInsertPointAtEnd(entry)
 c.rX = c.builder.CreateAlloca(llvm.Int8Type(), "X")
 c.rY = c.builder.CreateAlloca(llvm.Int8Type(), "Y")
 c.rA = c.builder.CreateAlloca(llvm.Int8Type(), "A")
 c.rSNeg = c.builder.CreateAlloca(llvm.Int1Type(), "S_neg")
 c.rSZero = c.builder.CreateAlloca(llvm.Int1Type(), "S_zero")

 // Second pass to build basic blocks.
 c.buildBasicBlocksPass()

 // Finally, one last pass for codegen.
 c.codeGenPass()

 // hook up the first entry block to the reset block
 c.builder.SetInsertPointAtEnd(entry)
 c.builder.CreateBr(*c.resetBlock)

 err := llvm.VerifyModule(c.mod, llvm.ReturnStatusAction)
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }

 // Uncomment this to print the LLVM IR code we just generated
 // to stderr.
 //c.mod.Dump()

 fd, err := os.Create(filename)
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }

 err = llvm.WriteBitcodeToFile(c.mod, fd)
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }

 err = fd.Close()
 if err != nil {
  c.Errors = append(c.Errors, err.Error())
  return
 }
}
</pre></div>

Here's what it the module looks like after only the first pass which identifies labeled data:

<div class="dir"><pre>
; ModuleID = 'asm_module'

@Label_c000 = private global [15 x i8] c"Hello, World!\0A\00"
</pre></div>

That's it. All we've done is created a global variable for <code>msg</code> (which is known as <code>Label_c000</code> in our disassembly) and saved it in the c.labeledData map.
<P>
Now add in the declares and main function definition, and we get:

<div class="nul"><pre>
; ModuleID = 'asm_module'

@Label_c000 = private global [15 x i8] c"Hello, World!\0A\00"

declare i32 @putchar(i32)

declare void @exit(i32) noreturn nounwind

define i32 @main() {
Entry:
  %X = alloca i8
  %Y = alloca i8
  %A = alloca i8
  %S_neg = alloca i1
  %S_zero = alloca i1
}
</pre></div>

Nothing fancy here. Next let's add in the second pass to identify basic blocks:

<div class="dir"><pre>
; ModuleID = 'asm_module'

@Label_c000 = private global [15 x i8] c"Hello, World!\0A\00"

declare i32 @putchar(i32)

declare void @exit(i32) noreturn nounwind

define i32 @main() {
Entry:
  %X = alloca i8
  %Y = alloca i8
  %A = alloca i8
  %S_neg = alloca i1
  %S_zero = alloca i1

Reset_Routine:                                    ; No predecessors!

Label_c011:                                       ; No predecessors!

Label_c01d:                                       ; No predecessors!

IRQ_Routine:                                      ; No predecessors!

NMI_Routine:                                      ; No predecessors!
}
</pre></div>

At this point we've created basic blocks for each of our labels and saved them in our <code>c.labeledBlocks</code> map.
<P>
And finally, we do the actual code generation pass and add the jump from the entry block to the reset block.
<P>
The actual code generation code is surprisingly simple. It consists of a switch case, and a few calls into the llvm builder object. For example, here's the code generation code for LDX #$00:

<div class="dir"><pre>
func (i *Instruction) Compile(c *Compilation) {
 v := llvm.ConstInt(llvm.Int8Type(), uint64(i.Value), false)
 switch i.OpCode {
 case 0xa2: // ldx
  c.builder.CreateStore(v, c.rX)
  c.testAndSetZero(i.Value)
  c.testAndSetNeg(i.Value)
 // more cases for other immediate instructions
 }
}

func (c *Compilation) testAndSetZero(v int) {
 if v == 0 {
  c.setZero()
  return
 }
 c.clearZero()
}

func (c *Compilation) setZero() {
 c.builder.CreateStore(llvm.ConstInt(llvm.Int1Type(), 1, false), c.rSZero)
}

func (c *Compilation) clearZero() {
 c.builder.CreateStore(llvm.ConstInt(llvm.Int1Type(), 0, false), c.rSZero)
}

func (c *Compilation) testAndSetNeg(v int) {
 if v&0x80 == 0x80 {
  c.setNeg()
  return
 }
 c.clearNeg()
}

func (c *Compilation) setNeg() {
 c.builder.CreateStore(llvm.ConstInt(llvm.Int1Type(), 1, false), c.rSNeg)
}

func (c *Compilation) clearNeg() {
 c.builder.CreateStore(llvm.ConstInt(llvm.Int1Type(), 0, false), c.rSNeg)
}
</pre></div>

For completeness's sake, let's look at one more code gen example. Here's the code generation code for LDA msg, X:

<div class="dir"><pre>
func (i *Instruction) Compile(c *Compilation) {
 switch i.OpCode {
 case 0xbd: // LDA label, X
  // Look up the global module variable based on the label name.
  dataPtr := c.labeledData[i.LabelName]
  index := c.builder.CreateLoad(c.rX, "")
  // This is what we index into the global variable with.
  indexes := []llvm.Value{
   llvm.ConstInt(llvm.Int8Type(), 0, false),
   index,
  }
  // Obtain a pointer to the element that we want to load.
  ptr := c.builder.CreateGEP(dataPtr, indexes, "")
  v := c.builder.CreateLoad(ptr, "")
  c.builder.CreateStore(v, c.rA)
  c.dynTestAndSetNeg(v)
  c.dynTestAndSetZero(v)
 // more cases for other direct-with-label-indexed instructions
 }
}

func (c *Compilation) dynTestAndSetNeg(v llvm.Value) {
 x80 := llvm.ConstInt(llvm.Int8Type(), uint64(0x80), false)
 masked := c.builder.CreateAnd(v, x80, "")
 isNeg := c.builder.CreateICmp(llvm.IntEQ, masked, x80, "")
 c.builder.CreateStore(isNeg, c.rSNeg)
}

func (c *Compilation) dynTestAndSetZero(v llvm.Value) {
 zeroConst := llvm.ConstInt(llvm.Int8Type(), uint64(0), false)
 isZero := c.builder.CreateICmp(llvm.IntEQ, v, zeroConst, "")
 c.builder.CreateStore(isZero, c.rSZero)
}
After implementing codegen for the rest of the instructions, here is the module dump after the code generation pass:

; ModuleID = 'asm_module'

@Label_c000 = private global [15 x i8] c"Hello, World!\0A\00"

declare i32 @putchar(i32)

declare void @exit(i32) noreturn nounwind

define i32 @main() {
Entry:
  %X = alloca i8
  %Y = alloca i8
  %A = alloca i8
  %S_neg = alloca i1
  %S_zero = alloca i1
  br label %Reset_Routine

Reset_Routine:                                    ; preds = %Entry
  store i8 0, i8* %X
  store i1 true, i1* %S_zero
  store i1 false, i1* %S_neg
  br label %Label_c011

Label_c011:                                       ; preds = %else, %Reset_Routine
  %0 = load i8* %X
  %1 = getelementptr [15 x i8]* @Label_c000, i8 0, i8 %0
  %2 = load i8* %1
  store i8 %2, i8* %A
  %3 = and i8 %2, -128
  %4 = icmp eq i8 %3, -128
  store i1 %4, i1* %S_neg
  %5 = icmp eq i8 %2, 0
  store i1 %5, i1* %S_zero
  %6 = load i1* %S_zero
  br i1 %6, label %Label_c01d, label %else

else:                                             ; preds = %Label_c011
  %7 = load i8* %A
  %8 = zext i8 %7 to i32
  %9 = call i32 @putchar(i32 %8)
  %10 = load i8* %X
  %11 = add i8 %10, 1
  store i8 %11, i8* %X
  %12 = and i8 %11, -128
  %13 = icmp eq i8 %12, -128
  store i1 %13, i1* %S_neg
  %14 = icmp eq i8 %11, 0
  store i1 %14, i1* %S_zero
  br label %Label_c011

Label_c01d:                                       ; preds = %Label_c011
  store i8 0, i8* %A
  store i1 true, i1* %S_zero
  store i1 false, i1* %S_neg
  %15 = load i8* %A
  %16 = zext i8 %15 to i32
  call void @exit(i32 %16)
  unreachable

IRQ_Routine:                                      ; preds = %Label_c01d
  unreachable

NMI_Routine:                                      ; No predecessors!
  unreachable
}
</pre></div>

Great! This looks just like the code we wanted to get, minus the comments and with a few things renamed. Let's make sure it runs as expected:

<div class="nul"><pre>
$ llc -filetype=obj hello.bc
$ gcc hello.bc.o
$ ./a.out
Hello, World!
$
</pre></div>

At this point in the project we are able to recompile a simple "Hello, World" 6502 program with a small custom ABI into native machine code and then execute it.


</body>
</html>