<html><title>Creating a Custom ABI for Testing Purposes</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

One of the challenges of NES development is that a basic "Hello, World" program is pretty complicated. This is why I created a custom Application Binary Interface to make it a little bit easier.<!--more--> Refer back to the memory layout above, and recall that many addresses are unused. I decided to add a couple things:

<div class="dir">
<code>$2008</code>  Write a byte to this address and the byte will go to standard out.
<div class="dir">
</div>
<code>$2009</code>  Write a byte to this address and the program will exit with that byte as the return code.
</div>

With this add-on ABI, I was able to create a simple 6502 application that prints "Hello, World!\n" to stdout and then exits. In 6502 land, that looks like:

<div class="nul"><pre>
; Remember that this code gets loaded at memory address $8000.
; This instruction tells the assembler that the code and data
; that follow are starting at address $8000.
; For example, the 'W' character in the "Hello, World!\n\0" text
; below is located at memory address $8007.
.org $8000

; This is a label. The assembler will replace references to
; this label with the actual address that it represents, which
; in this case is $8000.
msg:
; 'db' stands for "Data Bytes". This line puts the string
; "Hello, World!\n\0" in bytes $8000 - $800e when this
; code is assembled.
  .db "Hello, World!", 10, 0

Reset_Routine:
  LDX #$00       ; put the starting index, 0, in register X

loop:
; This instruction does 3 things:
; 1. Take the address of msg and add the value of register X to get a pointer.
; 2. Read the byte at the pointer and put it into register A
; 3. Set the zero flag to 1 if A is zero; or 0 if A is nonzero.
  LDA msg, X     ; read 1 char
; If the zero flag is 1, goto loopend. Otherwise, go to the next instruction.
  BEQ loopend    ; end loop if we hit the \0
; Put the value of register A into memory address $2008. But remember,
; with our custom ABI, this means write the value of register A to stdout.
  STA $2008      ; putchar
; Register X = Register X + 1
  INX
  JMP loop       ; goto loop

loopend:

  LDA #$00       ; put the return code, 0, in register A
  STA $2009      ; exit with a return code of register A (0 in this case)

; These are interrupt handlers. Let's not think about interrupts yet.
IRQ_Routine: RTI ; do nothing
NMI_Routine: RTI ; do nothing

; Another org statement. Remember that NES programs are 32KB. This tells the assembler
; to fill the unused space up until $fffa with zeroes and that we are now
; specifying the data at $fffa.
.org   $fffa

; 'dw' stands for "Data Words". These lines put the address of the NMI_Routine
; label at $fffa, the address of Reset_Routine at $fffc, and the address
; of IRQ_Routine at $fffe.
.dw  NMI_Routine
.dw  Reset_Routine
.dw  IRQ_Routine
</pre></div>

There are some things to point out here. First, note the entry points into the program. Whereas in most programming environments, there is a <code>main</code> function, in NES games, the data at <code>$fffa - $ffff</code> has hardcoded special meaning. When a game starts, the NES reads the 2 bytes at <code>$fffc and $fffd</code> and uses that as the memory address of the first instruction to run.
<P>
Next let's talk about the CPU. In the code snippet above I used register A and register X. There are 6 registers total:Name Bits Description

<div class="dir">
<code>A</code> <code>8-bit </code> The "main" register. Most of the arithmetic operations are performed on this register.
</div>

<div class="dir">
<code>X</code> <code> 8-bit</code> Another general purpose register. Fewer instructions support X than A. Often used as an index, as in the above code.
</div>

<div class="dir">
<code>Y</code> <code> 8-bit</code> Pretty much the same as X. Fewer instructions support Y than X. Also often used as an index.
</div>

<div class="dir">
<code>P</code> <code> 8-bit</code> The "status" register. When the assembly program mentions the "zero flag" it is actually referring to bit 1 (the second smallest bit) of the status register. The other bits mean other things, which we will get into later.
</div>

<div class="dir">
<code>SP</code> <code> 8-bit</code> The "stack pointer". The stack is located at <code>$100 - $1ff</code>. The stack pointer is initialized to <code>$1ff</code>. When you push a byte on the stack, the stack pointer is decremented, and when you pull a byte from the stack, the stack pointer is incremented.
</div>

<div class="dir">
<code>PC</code> <code> 16-bit</code> The program counter. You can't directly modify this register but you can indirectly modify it using the stack.
</div>

After coming up with this well-defined task - get "Hello World" running natively - it is time to write some code. First things first - this project should be able to assemble our source code into binary machine code format.



</body>
</html>
