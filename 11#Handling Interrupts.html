<html><title>Handling Interrupts</title>
<style type='text/css'>
body{margin:0px;}
.main, .widgetd {display:block;width:90%;height:auto;margin:auto;}
a:link, a:visited {text-decoration: none;color:#29e}
h3 a:link, h3 a:visited {color:#000}
.ilink a {float: left;font-size: 18px;}
.alink {margin:11px 6px;padding: 11px 0px;}
.alink a, .ilink a {padding:6px 10px;}
pre{overflow:auto;margin:0px;}
code {display: inline-block;padding: 0 .3em;border-radius: 3px;color: #333;border: 1px solid #ccc;
/* line-height: 1.6em; white-space: pre;*/}
.ileft {float:left;}
.iright {float:right;}
article.itmeouter {border-bottom: 3px solid #f1f1f1;;margin:6px 0px;padding: 11px 0;}
article.post {border-top: 3px solid #f1f1f1;margin:6px 0px;padding:11px 0;}
a.itemsmore {display:block;margin:16px 0;color:#000;text-align: right;}
.dir {margin:6px;padding: 0 11px;border-left: 3px solid #f00;}
.dir a {color:#f00}
.nul, .cover, .itag{display: block;margin: 11px 0 6px -5.6%;position: relative; font-family:Arial, Helvetica, Tahoma;}
.cover {width: 108%;padding: 0 1.6%;z-index: 1;}
.also {margin: 11px 0px;padding: 11px 0;}
.nul {background: #333;color:#fff;width: 100%;padding: 11px 5.6%;}
.itag {text-align: center;color:#000;}
.nul code {color: #fff !important;}
.adout {display: block;max-width:600px;min-width:290px;height:auto; margin: 16px auto;}
.icover {margin-top: 8%}
.input {display: block;max-width: 600px;min-width: 290px;margin:2px auto;}
.find, .search {display: block;padding: 6px 0px;font-size: 21px;border: 1px solid #aaa;border-radius: 3px;}
.find {width: 97%;float: left;}
.input .search {width: 100%;}
.ititle {font-size: 32px;text-align: center;}
.idir {text-align: center;}
.ititle, .idir, .Atitle {color:#fff;text-shadow: 0 0 6px #000;-webkit-text-shadow: 0 0 6px #000;-moz-text-shadow: 0 0 6px #000;}
.Atitle {margin:11px 0; }
.Atitle a {font-size: 21px;padding:0;color:#fff;}
.imggl {display: block;float: left;margin: 0 11px;}
.face {display: block;width:30%;height:auto;float: left;margin: 0 3.6%;background: #333;}
.face img {display: block;width:100%;height:auto;}
.clr {clear: both;float: none;}
@media screen and (max-width:1920px) {
div.post, article.post, body {font-size: 23px;}
}
@media screen and (max-width:1280px) {
div.post, article.post, body {font-size: 18px;}
}
@media screen and (max-width:800px) {
div.post, article.post, body {font-size: 16px;}
}
@media screen and (max-width:420px) {
.face {float:none;width: 320px;margin: 6px 0 6px -1.1%;width: 102.3%;}
.face img{float:none;width: 320px;margin:auto;}
}

</style>


<body>

In NES programming, after any instruction, it is possible that the program counter is yanked away from the next expected instruction and instead sent to a predefined location. This is called an interrupt.

There are 3 kinds of interrupts in NES programming:
<P>
<b>Reset</b><br>
Occurs when the user presses the reset button. This is also where the program counter starts when the NES powers on.
<P>
<b>IRQ</b><br>
Stands for Interrupt ReQuest. This interrupt can only be fired if a game uses a mapper or uses the <code>BRK</code> instruction. This request can be enabled and disabled with the <code>CLI and SEI</code> instructions.
<P>
<b>NMI</b><br>
Stands for Non-Maskable Interrupt because there are no instructions to enable and disable this interrupt. It occurs when the <a href="http://en.wikipedia.org/wiki/Vertical_blanking_interval">vertical blank</a> begins.
<P>
When an interrupt occurs, the program counter and status register are pushed onto the stack, and the program counter is set to the location defined by the interrupt vector table, as seen in code listings above:

<div class="nul"><pre>
.org $fffa
    .dw NMI_Routine
    .dw Reset_Routine
    .dw IRQ_Routine
</pre></div>

When a program has finished processing an interrupt, it typically executes the <code>RTI</code> instruction to return control flow back to where it was before the interrupt occurred.
<P>
We don't yet have to deal with handling the reset button being pressed, mappers, or games which execute the <code>BRK</code> instruction, so let's work on solving this problem for the NMI interrupt only.
<P>
The PPU performs the vertical blanking which signals the NMI interrupt, and the PPU emulation code is in the runtime. In order to handle NMI interrupts correctly, we have to be ready to jump to the interrupt routine after every single instruction.
<P>
We already call into the runtime by calling <code>rom_cycle</code> after every instruction. This is where the PPU emulation is performed, which is where the NMI interrupt is generated. Given this, a natural solution might be something like this:

<div class="dir">
Have <code>rom_cycle</code> return a value indicating which interrupt, if any, has occurred.
</div>

<div class="dir">
After every instruction, check if an interrupt has occurred, and if so, jump to the interrupt routine. Otherwise, continue.
</div>

This solution is rather ugly, however. Branching after every instruction decreases execution speed and executable leanness. Further, it leaves a critical problem unsolved: how to jump back to where the program counter was before the interrupt occurred. The solution I came up with instead feels better, but it comes with a caveat. Here's the idea:

<div class="dir">
Switch the register variables from being allocated on the stack in <code>rom_start</code>, to global variables in the generated module.
</div>

<div class="dir">
Update <code>rom_start</code>, the main entry point, to take a parameter indicating which interrupt vector to execute.
</div>

<div class="dir">
In the runtime, when <code>rom_start</code> is called for the first time, pass Reset as the interrupt vector to execute.
</div>

<div class="dir">
In the generated <code>rom_start</code> code, insert code at the beginning of the NMI interrupt routine block to push the program counter and the processor status to the stack.
</div>

<div class="dir">
In <code>rom_cycle</code>, if there is no interrupt, return as normal. However, if there is an interrupt, call <code>rom_start</code>, passing the correct interrupt vector to execute.
</div>

<div class="dir">
Generate a return statement for the <code>RTI</code> instruction.
</div>

The beauty of this solution is that it uses the real native stack for interrupts, in what is probably the most efficient and elegant way to get the desired behavior.
<P>
The caveat is that if the game uses <code>RTI</code> for its side-effects instead of the usual "return from interrupt" behavior, the executable will unexpectedly exit. Further, if the game simulates returning from an interrupt without using <code>RTI</code>, the game will crash due to a stack overflow.
<P>
Acknowledging these weaknesses, let's plow ahead until we are forced to solve this problem a different way. Let's see what it looks like to implement the plan. Update <code>rom_start</code> to take a parameter indicating which interrupt vector to execute:

<div class="nul"><pre>
func (p *Program) Compile(filename string) (c *Compilation) {
 // ...

 mainType := llvm.FunctionType(llvm.VoidType(), []llvm.Type{llvm.Int8Type()}, false)
 c.mainFn = llvm.AddFunction(c.mod, "rom_start", mainType)
 c.mainFn.SetFunctionCallConv(llvm.CCallConv)

 // ...
}
</pre></div>

Add a reset vector enum to rom.h:

<div class="nul"><pre>
enum {
    ROM_INTERRUPT_NONE,
    ROM_INTERRUPT_NMI,
    ROM_INTERRUPT_RESET,
    ROM_INTERRUPT_IRQ,
};
</pre></div>

In the runtime, when <code>rom_start</code> is called for the first time, pass Reset as the interrupt vector to execute. Also, in <code>rom_cycle</code>, if there is no interrupt, return as normal. However, if there is an interrupt, call <code>rom_start</code>, passing the correct interrupt vector to execute:

<div class="nul"><pre>
int interruptRequested = ROM_INTERRUPT_NONE;

void rom_cycle(uint8_t cycles) {
    flush_events();

    for (int i = 0; i &lt; 3 * cycles; ++i) {
        Ppu_step(p);
    }

    int req = interruptRequested;
    if (req != ROM_INTERRUPT_NONE) {
        interruptRequested = ROM_INTERRUPT_NONE;
        rom_start(req);
    }
}

void vblankInterrupt() {
    interruptRequested = ROM_INTERRUPT_NMI;
}

int main(int argc, char* argv[]) {
    p = Ppu_new();
    p-&gt;render = &render;

    // The PPU code will call this function when an NMI interrupt occurs.
    p-&gt;vblankInterrupt = &vblankInterrupt;

    Nametable_setMirroring(&p-&gt;nametables, rom_mirroring);
    assert(rom_chr_bank_count == 1);
    rom_read_chr(p-&gt;vram);
    init_video();

    // Start the rom executing at the Reset interrupt routine.
    rom_start(ROM_INTERRUPT_RESET);

    Ppu_dispose(p);
}
</pre></div>

In the generated <code>rom_start</code> code, insert code at the beginning of the NMI interrupt routine block to push the program counter and the processor status to the stack:

<div class="nul"><pre>
func (c *Compilation) addNmiInterruptCode() {
 c.builder.SetInsertPointBefore(c.nmiBlock.FirstInstruction())
 // * push PC high onto stack
 // * push PC low onto stack
 c.pushWordToStack(c.builder.CreateLoad(c.rPC, ""))
 // * push processor status onto stack
 c.pushToStack(c.getStatusByte())
}

func (c *Compilation) pushWordToStack(word llvm.Value) {
 high16 := c.builder.CreateLShr(word, llvm.ConstInt(llvm.Int16Type(), 8, false), "")
 high := c.builder.CreateTrunc(high16, llvm.Int8Type(), "")
 c.pushToStack(high)
 low16 := c.builder.CreateAnd(word, llvm.ConstInt(llvm.Int16Type(), 0xff, false), "")
 low := c.builder.CreateTrunc(low16, llvm.Int8Type(), "")
 c.pushToStack(low)
}

func (c *Compilation) pushToStack(v llvm.Value) {
 // write the value to the address at current stack pointer
 sp := c.builder.CreateLoad(c.rSP, "")
 spZExt := c.builder.CreateZExt(sp, llvm.Int16Type(), "")
 addr := c.builder.CreateAdd(spZExt, llvm.ConstInt(llvm.Int16Type(), 0x100, false), "")
 c.dynStore(addr, v)
 // stack pointer = stack pointer - 1
 spMinusOne := c.builder.CreateSub(sp, llvm.ConstInt(llvm.Int8Type(), 1, false), "")
 c.builder.CreateStore(spMinusOne, c.rSP)
}

func (c *Compilation) getStatusByte() llvm.Value {
 // zextend
 s7z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSNeg, ""), llvm.Int8Type(), "")
 s6z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSOver, ""), llvm.Int8Type(), "")
 s4z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSBrk, ""), llvm.Int8Type(), "")
 s3z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSDec, ""), llvm.Int8Type(), "")
 s2z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSInt, ""), llvm.Int8Type(), "")
 s1z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSZero, ""), llvm.Int8Type(), "")
 s0z := c.builder.CreateZExt(c.builder.CreateLoad(c.rSCarry, ""), llvm.Int8Type(), "")
 // shift
 s7z = c.builder.CreateShl(s7z, llvm.ConstInt(llvm.Int8Type(), 7, false), "")
 s6z = c.builder.CreateShl(s6z, llvm.ConstInt(llvm.Int8Type(), 6, false), "")
 s4z = c.builder.CreateShl(s4z, llvm.ConstInt(llvm.Int8Type(), 4, false), "")
 s3z = c.builder.CreateShl(s3z, llvm.ConstInt(llvm.Int8Type(), 3, false), "")
 s2z = c.builder.CreateShl(s2z, llvm.ConstInt(llvm.Int8Type(), 2, false), "")
 s1z = c.builder.CreateShl(s1z, llvm.ConstInt(llvm.Int8Type(), 1, false), "")
 // or
 s0z = c.builder.CreateOr(s0z, s1z, "")
 s0z = c.builder.CreateOr(s0z, s2z, "")
 s0z = c.builder.CreateOr(s0z, s3z, "")
 s0z = c.builder.CreateOr(s0z, s4z, "")
 s0z = c.builder.CreateOr(s0z, s6z, "")
 s0z = c.builder.CreateOr(s0z, s7z, "")
 return s0z
}
</pre></div>

Generate a return statement for the <code>RTI</code> instruction:

<div class="nul"><pre>
func (i *Instruction) Compile(c *Compilation) {
 switch i.OpCode {
 // ... other cases
 case 0x40: // RTI implied
  // Restore the old status register values from the stack.
  c.pullStatusReg()

  // We get the PC from the stack, but since we rely on the native
  // stack, we trash the value.
  _ = c.pullWordFromStack()

  // This will call the `rom_cycle` function. RTI always takes
  // 6 cycles.
  c.cycle(6)

  // Generate a return statement.
  c.builder.CreateRetVoid()

  // So that when another block is encountered, we do not
  // create an unconditional branch to it.
  c.currentBlock = nil

 // ... other cases
 }
}

func (c *Compilation) cycle(count int) {
 v := llvm.ConstInt(llvm.Int8Type(), uint64(count), false)
 c.builder.CreateCall(c.cycleFn, []llvm.Value{v}, "")
}
</pre></div>

And so here we have it: an elegant but imperfect solution to the interrupt problem. Let's see if it fixes the bent sword: Looks like progress to me! At this point the project can recompile a small, simple title screen demo NES program. The real challenge awaits: can it be made to work for a real NES game?  
<P>
There are many games to choose from. Ideally we would pick one that poses fewer additional challenges. One filter we can apply is to eliminate games that use mappers, since we have hitherto ignored mapper support entirely. This limits the choices significantly. The only games worth noting that do not use a mapper are: Donkey Kong, Ice Climber, Excitebike, Mario Bros, Super Mario Brothers and Pac-Man.
Of these, there is an obvious answer to which game we should support first, which, of course, is <a href="http://bootgod.dyndns.org:7777/profile.php?id=270">Super Mario Brothers</a>. Our next challenge is revealed when we crack open the disassembly for SMB.


</body>
</html>
